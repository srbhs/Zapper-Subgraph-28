// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Curve_to_Curve_PipeOwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_to_Curve_PipeOwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_to_Curve_PipeOwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_to_Curve_PipeOwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(id: string): Curve_to_Curve_PipeOwnershipTransferredEvent | null {
    return store.get(
      "Curve_to_Curve_PipeOwnershipTransferredEvent",
      id
    ) as Curve_to_Curve_PipeOwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Curve_to_Curve_PipeCurve2CurveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_to_Curve_PipeCurve2CurveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_to_Curve_PipeCurve2CurveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_to_Curve_PipeCurve2CurveCall", id.toString(), this);
  }

  static load(id: string): Curve_to_Curve_PipeCurve2CurveCall | null {
    return store.get(
      "Curve_to_Curve_PipeCurve2CurveCall",
      id
    ) as Curve_to_Curve_PipeCurve2CurveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_to_Curve_PipeapproveTokenCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_to_Curve_PipeapproveTokenCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_to_Curve_PipeapproveTokenCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_to_Curve_PipeapproveTokenCall", id.toString(), this);
  }

  static load(id: string): Curve_to_Curve_PipeapproveTokenCall | null {
    return store.get(
      "Curve_to_Curve_PipeapproveTokenCall",
      id
    ) as Curve_to_Curve_PipeapproveTokenCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_to_Curve_PipedestructCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_to_Curve_PipedestructCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_to_Curve_PipedestructCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_to_Curve_PipedestructCall", id.toString(), this);
  }

  static load(id: string): Curve_to_Curve_PipedestructCall | null {
    return store.get(
      "Curve_to_Curve_PipedestructCall",
      id
    ) as Curve_to_Curve_PipedestructCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_to_Curve_PipeinCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_to_Curve_PipeinCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_to_Curve_PipeinCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_to_Curve_PipeinCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(id: string): Curve_to_Curve_PipeinCaseTokengetsStuckCall | null {
    return store.get(
      "Curve_to_Curve_PipeinCaseTokengetsStuckCall",
      id
    ) as Curve_to_Curve_PipeinCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_to_Curve_PiperenounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_to_Curve_PiperenounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_to_Curve_PiperenounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_to_Curve_PiperenounceOwnershipCall", id.toString(), this);
  }

  static load(id: string): Curve_to_Curve_PiperenounceOwnershipCall | null {
    return store.get(
      "Curve_to_Curve_PiperenounceOwnershipCall",
      id
    ) as Curve_to_Curve_PiperenounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_to_Curve_PipetoggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_to_Curve_PipetoggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_to_Curve_PipetoggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_to_Curve_PipetoggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(id: string): Curve_to_Curve_PipetoggleContractActiveCall | null {
    return store.get(
      "Curve_to_Curve_PipetoggleContractActiveCall",
      id
    ) as Curve_to_Curve_PipetoggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_to_Curve_PipetransferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_to_Curve_PipetransferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_to_Curve_PipetransferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_to_Curve_PipetransferOwnershipCall", id.toString(), this);
  }

  static load(id: string): Curve_to_Curve_PipetransferOwnershipCall | null {
    return store.get(
      "Curve_to_Curve_PipetransferOwnershipCall",
      id
    ) as Curve_to_Curve_PipetransferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Curve_to_Curve_PipewithdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_to_Curve_PipewithdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_to_Curve_PipewithdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_to_Curve_PipewithdrawCall", id.toString(), this);
  }

  static load(id: string): Curve_to_Curve_PipewithdrawCall | null {
    return store.get(
      "Curve_to_Curve_PipewithdrawCall",
      id
    ) as Curve_to_Curve_PipewithdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Uni_Curve_PipeOwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_Curve_PipeOwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_Curve_PipeOwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_Curve_PipeOwnershipTransferredEvent", id.toString(), this);
  }

  static load(id: string): Uni_Curve_PipeOwnershipTransferredEvent | null {
    return store.get(
      "Uni_Curve_PipeOwnershipTransferredEvent",
      id
    ) as Uni_Curve_PipeOwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Uni_Curve_PipeCurve2UniCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_Curve_PipeCurve2UniCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_Curve_PipeCurve2UniCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_Curve_PipeCurve2UniCall", id.toString(), this);
  }

  static load(id: string): Uni_Curve_PipeCurve2UniCall | null {
    return store.get(
      "Uni_Curve_PipeCurve2UniCall",
      id
    ) as Uni_Curve_PipeCurve2UniCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Uni_Curve_PipeUni2CurveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_Curve_PipeUni2CurveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_Curve_PipeUni2CurveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_Curve_PipeUni2CurveCall", id.toString(), this);
  }

  static load(id: string): Uni_Curve_PipeUni2CurveCall | null {
    return store.get(
      "Uni_Curve_PipeUni2CurveCall",
      id
    ) as Uni_Curve_PipeUni2CurveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Uni_Curve_PipeapproveTokenCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_Curve_PipeapproveTokenCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_Curve_PipeapproveTokenCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_Curve_PipeapproveTokenCall", id.toString(), this);
  }

  static load(id: string): Uni_Curve_PipeapproveTokenCall | null {
    return store.get(
      "Uni_Curve_PipeapproveTokenCall",
      id
    ) as Uni_Curve_PipeapproveTokenCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Uni_Curve_PipedestructCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_Curve_PipedestructCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_Curve_PipedestructCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_Curve_PipedestructCall", id.toString(), this);
  }

  static load(id: string): Uni_Curve_PipedestructCall | null {
    return store.get(
      "Uni_Curve_PipedestructCall",
      id
    ) as Uni_Curve_PipedestructCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Uni_Curve_PipeinCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_Curve_PipeinCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_Curve_PipeinCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_Curve_PipeinCaseTokengetsStuckCall", id.toString(), this);
  }

  static load(id: string): Uni_Curve_PipeinCaseTokengetsStuckCall | null {
    return store.get(
      "Uni_Curve_PipeinCaseTokengetsStuckCall",
      id
    ) as Uni_Curve_PipeinCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Uni_Curve_PiperenounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_Curve_PiperenounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_Curve_PiperenounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_Curve_PiperenounceOwnershipCall", id.toString(), this);
  }

  static load(id: string): Uni_Curve_PiperenounceOwnershipCall | null {
    return store.get(
      "Uni_Curve_PiperenounceOwnershipCall",
      id
    ) as Uni_Curve_PiperenounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Uni_Curve_PipetoggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_Curve_PipetoggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_Curve_PipetoggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_Curve_PipetoggleContractActiveCall", id.toString(), this);
  }

  static load(id: string): Uni_Curve_PipetoggleContractActiveCall | null {
    return store.get(
      "Uni_Curve_PipetoggleContractActiveCall",
      id
    ) as Uni_Curve_PipetoggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Uni_Curve_PipetransferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_Curve_PipetransferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_Curve_PipetransferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_Curve_PipetransferOwnershipCall", id.toString(), this);
  }

  static load(id: string): Uni_Curve_PipetransferOwnershipCall | null {
    return store.get(
      "Uni_Curve_PipetransferOwnershipCall",
      id
    ) as Uni_Curve_PipetransferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Uni_Curve_PipewithdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_Curve_PipewithdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_Curve_PipewithdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_Curve_PipewithdrawCall", id.toString(), this);
  }

  static load(id: string): Uni_Curve_PipewithdrawCall | null {
    return store.get(
      "Uni_Curve_PipewithdrawCall",
      id
    ) as Uni_Curve_PipewithdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ETH_ERC20_Curve_General_Zap_V1OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ETH_ERC20_Curve_General_Zap_V1OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ETH_ERC20_Curve_General_Zap_V1OwnershipTransferredEvent | null {
    return store.get(
      "ETH_ERC20_Curve_General_Zap_V1OwnershipTransferredEvent",
      id
    ) as ETH_ERC20_Curve_General_Zap_V1OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class ETH_ERC20_Curve_General_Zap_V1ZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1ZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1ZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ETH_ERC20_Curve_General_Zap_V1ZapInCall", id.toString(), this);
  }

  static load(id: string): ETH_ERC20_Curve_General_Zap_V1ZapInCall | null {
    return store.get(
      "ETH_ERC20_Curve_General_Zap_V1ZapInCall",
      id
    ) as ETH_ERC20_Curve_General_Zap_V1ZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get crvTokensBought(): BigInt {
    let value = this.get("crvTokensBought");
    return value.toBigInt();
  }

  set crvTokensBought(value: BigInt) {
    this.set("crvTokensBought", Value.fromBigInt(value));
  }
}

export class ETH_ERC20_Curve_General_Zap_V1approveTokenCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1approveTokenCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1approveTokenCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ETH_ERC20_Curve_General_Zap_V1approveTokenCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ETH_ERC20_Curve_General_Zap_V1approveTokenCall | null {
    return store.get(
      "ETH_ERC20_Curve_General_Zap_V1approveTokenCall",
      id
    ) as ETH_ERC20_Curve_General_Zap_V1approveTokenCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ETH_ERC20_Curve_General_Zap_V1destructCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1destructCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1destructCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ETH_ERC20_Curve_General_Zap_V1destructCall",
      id.toString(),
      this
    );
  }

  static load(id: string): ETH_ERC20_Curve_General_Zap_V1destructCall | null {
    return store.get(
      "ETH_ERC20_Curve_General_Zap_V1destructCall",
      id
    ) as ETH_ERC20_Curve_General_Zap_V1destructCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ETH_ERC20_Curve_General_Zap_V1inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ETH_ERC20_Curve_General_Zap_V1inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ETH_ERC20_Curve_General_Zap_V1inCaseTokengetsStuckCall | null {
    return store.get(
      "ETH_ERC20_Curve_General_Zap_V1inCaseTokengetsStuckCall",
      id
    ) as ETH_ERC20_Curve_General_Zap_V1inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ETH_ERC20_Curve_General_Zap_V1renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ETH_ERC20_Curve_General_Zap_V1renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ETH_ERC20_Curve_General_Zap_V1renounceOwnershipCall | null {
    return store.get(
      "ETH_ERC20_Curve_General_Zap_V1renounceOwnershipCall",
      id
    ) as ETH_ERC20_Curve_General_Zap_V1renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ETH_ERC20_Curve_General_Zap_V1setnewdzgoodwillAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1setnewdzgoodwillAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1setnewdzgoodwillAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ETH_ERC20_Curve_General_Zap_V1setnewdzgoodwillAddressCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ETH_ERC20_Curve_General_Zap_V1setnewdzgoodwillAddressCall | null {
    return store.get(
      "ETH_ERC20_Curve_General_Zap_V1setnewdzgoodwillAddressCall",
      id
    ) as ETH_ERC20_Curve_General_Zap_V1setnewdzgoodwillAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ETH_ERC20_Curve_General_Zap_V1setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ETH_ERC20_Curve_General_Zap_V1setnewgoodwillCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ETH_ERC20_Curve_General_Zap_V1setnewgoodwillCall | null {
    return store.get(
      "ETH_ERC20_Curve_General_Zap_V1setnewgoodwillCall",
      id
    ) as ETH_ERC20_Curve_General_Zap_V1setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ETH_ERC20_Curve_General_Zap_V1toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ETH_ERC20_Curve_General_Zap_V1toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ETH_ERC20_Curve_General_Zap_V1toggleContractActiveCall | null {
    return store.get(
      "ETH_ERC20_Curve_General_Zap_V1toggleContractActiveCall",
      id
    ) as ETH_ERC20_Curve_General_Zap_V1toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ETH_ERC20_Curve_General_Zap_V1transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ETH_ERC20_Curve_General_Zap_V1transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ETH_ERC20_Curve_General_Zap_V1transferOwnershipCall | null {
    return store.get(
      "ETH_ERC20_Curve_General_Zap_V1transferOwnershipCall",
      id
    ) as ETH_ERC20_Curve_General_Zap_V1transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class ETH_ERC20_Curve_General_Zap_V1withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ETH_ERC20_Curve_General_Zap_V1withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ETH_ERC20_Curve_General_Zap_V1withdrawCall",
      id.toString(),
      this
    );
  }

  static load(id: string): ETH_ERC20_Curve_General_Zap_V1withdrawCall | null {
    return store.get(
      "ETH_ERC20_Curve_General_Zap_V1withdrawCall",
      id
    ) as ETH_ERC20_Curve_General_Zap_V1withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class MultiPoolZapV1_4OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save MultiPoolZapV1_4OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MultiPoolZapV1_4OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MultiPoolZapV1_4OwnershipTransferredEvent", id.toString(), this);
  }

  static load(id: string): MultiPoolZapV1_4OwnershipTransferredEvent | null {
    return store.get(
      "MultiPoolZapV1_4OwnershipTransferredEvent",
      id
    ) as MultiPoolZapV1_4OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class MultiPoolZapV1_4multipleZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save MultiPoolZapV1_4multipleZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MultiPoolZapV1_4multipleZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MultiPoolZapV1_4multipleZapInCall", id.toString(), this);
  }

  static load(id: string): MultiPoolZapV1_4multipleZapInCall | null {
    return store.get(
      "MultiPoolZapV1_4multipleZapInCall",
      id
    ) as MultiPoolZapV1_4multipleZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get underlyingTokenAddresses(): Array<Address> {
    let value = this.get("underlyingTokenAddresses");
    return value.toAddressArray();
  }

  set underlyingTokenAddresses(value: Array<Address>) {
    this.set("underlyingTokenAddresses", Value.fromAddressArray(value));
  }

  get respectiveWeightedValues(): Array<BigInt> {
    let value = this.get("respectiveWeightedValues");
    return value.toBigIntArray();
  }

  set respectiveWeightedValues(value: Array<BigInt>) {
    this.set("respectiveWeightedValues", Value.fromBigIntArray(value));
  }
}

export class MultiPoolZapV1_4renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save MultiPoolZapV1_4renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MultiPoolZapV1_4renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MultiPoolZapV1_4renounceOwnershipCall", id.toString(), this);
  }

  static load(id: string): MultiPoolZapV1_4renounceOwnershipCall | null {
    return store.get(
      "MultiPoolZapV1_4renounceOwnershipCall",
      id
    ) as MultiPoolZapV1_4renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class MultiPoolZapV1_4setUniswapFactoryCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save MultiPoolZapV1_4setUniswapFactoryCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MultiPoolZapV1_4setUniswapFactoryCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MultiPoolZapV1_4setUniswapFactoryCall", id.toString(), this);
  }

  static load(id: string): MultiPoolZapV1_4setUniswapFactoryCall | null {
    return store.get(
      "MultiPoolZapV1_4setUniswapFactoryCall",
      id
    ) as MultiPoolZapV1_4setUniswapFactoryCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class MultiPoolZapV1_4setnewdzgoodwillAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save MultiPoolZapV1_4setnewdzgoodwillAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MultiPoolZapV1_4setnewdzgoodwillAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "MultiPoolZapV1_4setnewdzgoodwillAddressCall",
      id.toString(),
      this
    );
  }

  static load(id: string): MultiPoolZapV1_4setnewdzgoodwillAddressCall | null {
    return store.get(
      "MultiPoolZapV1_4setnewdzgoodwillAddressCall",
      id
    ) as MultiPoolZapV1_4setnewdzgoodwillAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class MultiPoolZapV1_4setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save MultiPoolZapV1_4setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MultiPoolZapV1_4setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MultiPoolZapV1_4setnewgoodwillCall", id.toString(), this);
  }

  static load(id: string): MultiPoolZapV1_4setnewgoodwillCall | null {
    return store.get(
      "MultiPoolZapV1_4setnewgoodwillCall",
      id
    ) as MultiPoolZapV1_4setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class MultiPoolZapV1_4setuniswapPoolZapAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save MultiPoolZapV1_4setuniswapPoolZapAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MultiPoolZapV1_4setuniswapPoolZapAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "MultiPoolZapV1_4setuniswapPoolZapAddressCall",
      id.toString(),
      this
    );
  }

  static load(id: string): MultiPoolZapV1_4setuniswapPoolZapAddressCall | null {
    return store.get(
      "MultiPoolZapV1_4setuniswapPoolZapAddressCall",
      id
    ) as MultiPoolZapV1_4setuniswapPoolZapAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class MultiPoolZapV1_4transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save MultiPoolZapV1_4transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MultiPoolZapV1_4transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MultiPoolZapV1_4transferOwnershipCall", id.toString(), this);
  }

  static load(id: string): MultiPoolZapV1_4transferOwnershipCall | null {
    return store.get(
      "MultiPoolZapV1_4transferOwnershipCall",
      id
    ) as MultiPoolZapV1_4transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class ERC20toUniPoolZapV2_GeneraldetailsEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ERC20toUniPoolZapV2_GeneraldetailsEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ERC20toUniPoolZapV2_GeneraldetailsEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ERC20toUniPoolZapV2_GeneraldetailsEvent", id.toString(), this);
  }

  static load(id: string): ERC20toUniPoolZapV2_GeneraldetailsEvent | null {
    return store.get(
      "ERC20toUniPoolZapV2_GeneraldetailsEvent",
      id
    ) as ERC20toUniPoolZapV2_GeneraldetailsEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get toWhomIssued(): Bytes {
    let value = this.get("toWhomIssued");
    return value.toBytes();
  }

  set toWhomIssued(value: Bytes) {
    this.set("toWhomIssued", Value.fromBytes(value));
  }

  get IncomingTokenAddress(): Bytes {
    let value = this.get("IncomingTokenAddress");
    return value.toBytes();
  }

  set IncomingTokenAddress(value: Bytes) {
    this.set("IncomingTokenAddress", Value.fromBytes(value));
  }

  get UniPoolUnderlyingTokenAddressTokenAddress(): Bytes {
    let value = this.get("UniPoolUnderlyingTokenAddressTokenAddress");
    return value.toBytes();
  }

  set UniPoolUnderlyingTokenAddressTokenAddress(value: Bytes) {
    this.set(
      "UniPoolUnderlyingTokenAddressTokenAddress",
      Value.fromBytes(value)
    );
  }
}

export class ERC20toUniPoolZapV2_GeneralresidualETHEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ERC20toUniPoolZapV2_GeneralresidualETHEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ERC20toUniPoolZapV2_GeneralresidualETHEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ERC20toUniPoolZapV2_GeneralresidualETHEvent",
      id.toString(),
      this
    );
  }

  static load(id: string): ERC20toUniPoolZapV2_GeneralresidualETHEvent | null {
    return store.get(
      "ERC20toUniPoolZapV2_GeneralresidualETHEvent",
      id
    ) as ERC20toUniPoolZapV2_GeneralresidualETHEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get residualETHtransferred(): BigInt {
    let value = this.get("residualETHtransferred");
    return value.toBigInt();
  }

  set residualETHtransferred(value: BigInt) {
    this.set("residualETHtransferred", Value.fromBigInt(value));
  }
}

export class ERC20toUniPoolZapV2_GeneralLetsInvestCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ERC20toUniPoolZapV2_GeneralLetsInvestCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ERC20toUniPoolZapV2_GeneralLetsInvestCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ERC20toUniPoolZapV2_GeneralLetsInvestCall", id.toString(), this);
  }

  static load(id: string): ERC20toUniPoolZapV2_GeneralLetsInvestCall | null {
    return store.get(
      "ERC20toUniPoolZapV2_GeneralLetsInvestCall",
      id
    ) as ERC20toUniPoolZapV2_GeneralLetsInvestCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): boolean {
    let value = this.get("value0");
    return value.toBoolean();
  }

  set value0(value: boolean) {
    this.set("value0", Value.fromBoolean(value));
  }
}

export class ERC20toUniPoolZapV2_GeneralinCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ERC20toUniPoolZapV2_GeneralinCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ERC20toUniPoolZapV2_GeneralinCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ERC20toUniPoolZapV2_GeneralinCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ERC20toUniPoolZapV2_GeneralinCaseTokengetsStuckCall | null {
    return store.get(
      "ERC20toUniPoolZapV2_GeneralinCaseTokengetsStuckCall",
      id
    ) as ERC20toUniPoolZapV2_GeneralinCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ERC20toUniPoolZapV2_GeneraltoggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ERC20toUniPoolZapV2_GeneraltoggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ERC20toUniPoolZapV2_GeneraltoggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ERC20toUniPoolZapV2_GeneraltoggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ERC20toUniPoolZapV2_GeneraltoggleContractActiveCall | null {
    return store.get(
      "ERC20toUniPoolZapV2_GeneraltoggleContractActiveCall",
      id
    ) as ERC20toUniPoolZapV2_GeneraltoggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ERC20toUniPoolZapV2_GeneraltransferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ERC20toUniPoolZapV2_GeneraltransferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ERC20toUniPoolZapV2_GeneraltransferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ERC20toUniPoolZapV2_GeneraltransferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ERC20toUniPoolZapV2_GeneraltransferOwnershipCall | null {
    return store.get(
      "ERC20toUniPoolZapV2_GeneraltransferOwnershipCall",
      id
    ) as ERC20toUniPoolZapV2_GeneraltransferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class ERC20toUniPoolZapV2_GeneralwithdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ERC20toUniPoolZapV2_GeneralwithdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ERC20toUniPoolZapV2_GeneralwithdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ERC20toUniPoolZapV2_GeneralwithdrawCall", id.toString(), this);
  }

  static load(id: string): ERC20toUniPoolZapV2_GeneralwithdrawCall | null {
    return store.get(
      "ERC20toUniPoolZapV2_GeneralwithdrawCall",
      id
    ) as ERC20toUniPoolZapV2_GeneralwithdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ERC20toUniPoolZapV1_GeneraldetailsEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ERC20toUniPoolZapV1_GeneraldetailsEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ERC20toUniPoolZapV1_GeneraldetailsEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ERC20toUniPoolZapV1_GeneraldetailsEvent", id.toString(), this);
  }

  static load(id: string): ERC20toUniPoolZapV1_GeneraldetailsEvent | null {
    return store.get(
      "ERC20toUniPoolZapV1_GeneraldetailsEvent",
      id
    ) as ERC20toUniPoolZapV1_GeneraldetailsEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get toWhomIssued(): Bytes {
    let value = this.get("toWhomIssued");
    return value.toBytes();
  }

  set toWhomIssued(value: Bytes) {
    this.set("toWhomIssued", Value.fromBytes(value));
  }

  get IncomingTokenAddress(): Bytes {
    let value = this.get("IncomingTokenAddress");
    return value.toBytes();
  }

  set IncomingTokenAddress(value: Bytes) {
    this.set("IncomingTokenAddress", Value.fromBytes(value));
  }

  get UniPoolUnderlyingTokenAddressTokenAddress(): Bytes {
    let value = this.get("UniPoolUnderlyingTokenAddressTokenAddress");
    return value.toBytes();
  }

  set UniPoolUnderlyingTokenAddressTokenAddress(value: Bytes) {
    this.set(
      "UniPoolUnderlyingTokenAddressTokenAddress",
      Value.fromBytes(value)
    );
  }
}

export class ERC20toUniPoolZapV1_GeneralresidualETHEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ERC20toUniPoolZapV1_GeneralresidualETHEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ERC20toUniPoolZapV1_GeneralresidualETHEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ERC20toUniPoolZapV1_GeneralresidualETHEvent",
      id.toString(),
      this
    );
  }

  static load(id: string): ERC20toUniPoolZapV1_GeneralresidualETHEvent | null {
    return store.get(
      "ERC20toUniPoolZapV1_GeneralresidualETHEvent",
      id
    ) as ERC20toUniPoolZapV1_GeneralresidualETHEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get residualETHtransferred(): BigInt {
    let value = this.get("residualETHtransferred");
    return value.toBigInt();
  }

  set residualETHtransferred(value: BigInt) {
    this.set("residualETHtransferred", Value.fromBigInt(value));
  }
}

export class ERC20toUniPoolZapV1_GeneralLetsInvestCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ERC20toUniPoolZapV1_GeneralLetsInvestCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ERC20toUniPoolZapV1_GeneralLetsInvestCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ERC20toUniPoolZapV1_GeneralLetsInvestCall", id.toString(), this);
  }

  static load(id: string): ERC20toUniPoolZapV1_GeneralLetsInvestCall | null {
    return store.get(
      "ERC20toUniPoolZapV1_GeneralLetsInvestCall",
      id
    ) as ERC20toUniPoolZapV1_GeneralLetsInvestCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): boolean {
    let value = this.get("value0");
    return value.toBoolean();
  }

  set value0(value: boolean) {
    this.set("value0", Value.fromBoolean(value));
  }
}

export class ERC20toUniPoolZapV1_GeneralinCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ERC20toUniPoolZapV1_GeneralinCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ERC20toUniPoolZapV1_GeneralinCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ERC20toUniPoolZapV1_GeneralinCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ERC20toUniPoolZapV1_GeneralinCaseTokengetsStuckCall | null {
    return store.get(
      "ERC20toUniPoolZapV1_GeneralinCaseTokengetsStuckCall",
      id
    ) as ERC20toUniPoolZapV1_GeneralinCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ERC20toUniPoolZapV1_GeneraltoggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ERC20toUniPoolZapV1_GeneraltoggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ERC20toUniPoolZapV1_GeneraltoggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ERC20toUniPoolZapV1_GeneraltoggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ERC20toUniPoolZapV1_GeneraltoggleContractActiveCall | null {
    return store.get(
      "ERC20toUniPoolZapV1_GeneraltoggleContractActiveCall",
      id
    ) as ERC20toUniPoolZapV1_GeneraltoggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ERC20toUniPoolZapV1_GeneraltransferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ERC20toUniPoolZapV1_GeneraltransferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ERC20toUniPoolZapV1_GeneraltransferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ERC20toUniPoolZapV1_GeneraltransferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ERC20toUniPoolZapV1_GeneraltransferOwnershipCall | null {
    return store.get(
      "ERC20toUniPoolZapV1_GeneraltransferOwnershipCall",
      id
    ) as ERC20toUniPoolZapV1_GeneraltransferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class ERC20toUniPoolZapV1_GeneralwithdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ERC20toUniPoolZapV1_GeneralwithdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ERC20toUniPoolZapV1_GeneralwithdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ERC20toUniPoolZapV1_GeneralwithdrawCall", id.toString(), this);
  }

  static load(id: string): ERC20toUniPoolZapV1_GeneralwithdrawCall | null {
    return store.get(
      "ERC20toUniPoolZapV1_GeneralwithdrawCall",
      id
    ) as ERC20toUniPoolZapV1_GeneralwithdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_Unzap_V1_1OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(id: string): Balancer_Unzap_V1_1OwnershipTransferredEvent | null {
    return store.get(
      "Balancer_Unzap_V1_1OwnershipTransferredEvent",
      id
    ) as Balancer_Unzap_V1_1OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_Unzap_V1_1ZapoutEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1ZapoutEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1ZapoutEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_Unzap_V1_1ZapoutEvent", id.toString(), this);
  }

  static load(id: string): Balancer_Unzap_V1_1ZapoutEvent | null {
    return store.get(
      "Balancer_Unzap_V1_1ZapoutEvent",
      id
    ) as Balancer_Unzap_V1_1ZapoutEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1EasyZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1EasyZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1EasyZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_Unzap_V1_1EasyZapOutCall", id.toString(), this);
  }

  static load(id: string): Balancer_Unzap_V1_1EasyZapOutCall | null {
    return store.get(
      "Balancer_Unzap_V1_1EasyZapOutCall",
      id
    ) as Balancer_Unzap_V1_1EasyZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get slippage(): BigInt {
    let value = this.get("slippage");
    return value.toBigInt();
  }

  set slippage(value: BigInt) {
    this.set("slippage", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1ZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1ZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1ZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_Unzap_V1_1ZapOutCall", id.toString(), this);
  }

  static load(id: string): Balancer_Unzap_V1_1ZapOutCall | null {
    return store.get(
      "Balancer_Unzap_V1_1ZapOutCall",
      id
    ) as Balancer_Unzap_V1_1ZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get slippage(): BigInt {
    let value = this.get("slippage");
    return value.toBigInt();
  }

  set slippage(value: BigInt) {
    this.set("slippage", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1destructCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1destructCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1destructCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_Unzap_V1_1destructCall", id.toString(), this);
  }

  static load(id: string): Balancer_Unzap_V1_1destructCall | null {
    return store.get(
      "Balancer_Unzap_V1_1destructCall",
      id
    ) as Balancer_Unzap_V1_1destructCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_Unzap_V1_1inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(id: string): Balancer_Unzap_V1_1inCaseTokengetsStuckCall | null {
    return store.get(
      "Balancer_Unzap_V1_1inCaseTokengetsStuckCall",
      id
    ) as Balancer_Unzap_V1_1inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_Unzap_V1_1renounceOwnershipCall", id.toString(), this);
  }

  static load(id: string): Balancer_Unzap_V1_1renounceOwnershipCall | null {
    return store.get(
      "Balancer_Unzap_V1_1renounceOwnershipCall",
      id
    ) as Balancer_Unzap_V1_1renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1setnewdzgoodwillAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1setnewdzgoodwillAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1setnewdzgoodwillAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_Unzap_V1_1setnewdzgoodwillAddressCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_Unzap_V1_1setnewdzgoodwillAddressCall | null {
    return store.get(
      "Balancer_Unzap_V1_1setnewdzgoodwillAddressCall",
      id
    ) as Balancer_Unzap_V1_1setnewdzgoodwillAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_Unzap_V1_1setnewgoodwillCall", id.toString(), this);
  }

  static load(id: string): Balancer_Unzap_V1_1setnewgoodwillCall | null {
    return store.get(
      "Balancer_Unzap_V1_1setnewgoodwillCall",
      id
    ) as Balancer_Unzap_V1_1setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_Unzap_V1_1toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(id: string): Balancer_Unzap_V1_1toggleContractActiveCall | null {
    return store.get(
      "Balancer_Unzap_V1_1toggleContractActiveCall",
      id
    ) as Balancer_Unzap_V1_1toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_Unzap_V1_1transferOwnershipCall", id.toString(), this);
  }

  static load(id: string): Balancer_Unzap_V1_1transferOwnershipCall | null {
    return store.get(
      "Balancer_Unzap_V1_1transferOwnershipCall",
      id
    ) as Balancer_Unzap_V1_1transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_Unzap_V1_1updateSlippageCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1updateSlippageCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1updateSlippageCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_Unzap_V1_1updateSlippageCall", id.toString(), this);
  }

  static load(id: string): Balancer_Unzap_V1_1updateSlippageCall | null {
    return store.get(
      "Balancer_Unzap_V1_1updateSlippageCall",
      id
    ) as Balancer_Unzap_V1_1updateSlippageCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_Unzap_V1_1withdrawCall", id.toString(), this);
  }

  static load(id: string): Balancer_Unzap_V1_1withdrawCall | null {
    return store.get(
      "Balancer_Unzap_V1_1withdrawCall",
      id
    ) as Balancer_Unzap_V1_1withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V1OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V1OwnershipTransferredEvent | null {
    return store.get(
      "Balancer_ZapIn_General_V1OwnershipTransferredEvent",
      id
    ) as Balancer_ZapIn_General_V1OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_ZapIn_General_V1ZapinEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1ZapinEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1ZapinEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V1ZapinEvent", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V1ZapinEvent | null {
    return store.get(
      "Balancer_ZapIn_General_V1ZapinEvent",
      id
    ) as Balancer_ZapIn_General_V1ZapinEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1EasyZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1EasyZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1EasyZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V1EasyZapInCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V1EasyZapInCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1EasyZapInCall",
      id
    ) as Balancer_ZapIn_General_V1EasyZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get tokensBought(): BigInt {
    let value = this.get("tokensBought");
    return value.toBigInt();
  }

  set tokensBought(value: BigInt) {
    this.set("tokensBought", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1ZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1ZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1ZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V1ZapInCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V1ZapInCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1ZapInCall",
      id
    ) as Balancer_ZapIn_General_V1ZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get tokensBought(): BigInt {
    let value = this.get("tokensBought");
    return value.toBigInt();
  }

  set tokensBought(value: BigInt) {
    this.set("tokensBought", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1destructCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1destructCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1destructCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V1destructCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V1destructCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1destructCall",
      id
    ) as Balancer_ZapIn_General_V1destructCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V1inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V1inCaseTokengetsStuckCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1inCaseTokengetsStuckCall",
      id
    ) as Balancer_ZapIn_General_V1inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V1renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V1renounceOwnershipCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1renounceOwnershipCall",
      id
    ) as Balancer_ZapIn_General_V1renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1setnewdzgoodwillAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1setnewdzgoodwillAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1setnewdzgoodwillAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V1setnewdzgoodwillAddressCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V1setnewdzgoodwillAddressCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1setnewdzgoodwillAddressCall",
      id
    ) as Balancer_ZapIn_General_V1setnewdzgoodwillAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V1setnewgoodwillCall",
      id.toString(),
      this
    );
  }

  static load(id: string): Balancer_ZapIn_General_V1setnewgoodwillCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1setnewgoodwillCall",
      id
    ) as Balancer_ZapIn_General_V1setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V1toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V1toggleContractActiveCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1toggleContractActiveCall",
      id
    ) as Balancer_ZapIn_General_V1toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V1transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V1transferOwnershipCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1transferOwnershipCall",
      id
    ) as Balancer_ZapIn_General_V1transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_ZapIn_General_V1withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V1withdrawCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V1withdrawCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1withdrawCall",
      id
    ) as Balancer_ZapIn_General_V1withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1_1OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1_1OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1_1OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_Unzap_V1_1_1OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_Unzap_V1_1_1OwnershipTransferredEvent | null {
    return store.get(
      "Balancer_Unzap_V1_1_1OwnershipTransferredEvent",
      id
    ) as Balancer_Unzap_V1_1_1OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_Unzap_V1_1_1ZapoutEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1_1ZapoutEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1_1ZapoutEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_Unzap_V1_1_1ZapoutEvent", id.toString(), this);
  }

  static load(id: string): Balancer_Unzap_V1_1_1ZapoutEvent | null {
    return store.get(
      "Balancer_Unzap_V1_1_1ZapoutEvent",
      id
    ) as Balancer_Unzap_V1_1_1ZapoutEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1_1EasyZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1_1EasyZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1_1EasyZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_Unzap_V1_1_1EasyZapOutCall", id.toString(), this);
  }

  static load(id: string): Balancer_Unzap_V1_1_1EasyZapOutCall | null {
    return store.get(
      "Balancer_Unzap_V1_1_1EasyZapOutCall",
      id
    ) as Balancer_Unzap_V1_1_1EasyZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get slippage(): BigInt {
    let value = this.get("slippage");
    return value.toBigInt();
  }

  set slippage(value: BigInt) {
    this.set("slippage", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1_1ZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1_1ZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1_1ZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_Unzap_V1_1_1ZapOutCall", id.toString(), this);
  }

  static load(id: string): Balancer_Unzap_V1_1_1ZapOutCall | null {
    return store.get(
      "Balancer_Unzap_V1_1_1ZapOutCall",
      id
    ) as Balancer_Unzap_V1_1_1ZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get slippage(): BigInt {
    let value = this.get("slippage");
    return value.toBigInt();
  }

  set slippage(value: BigInt) {
    this.set("slippage", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1_1destructCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1_1destructCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1_1destructCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_Unzap_V1_1_1destructCall", id.toString(), this);
  }

  static load(id: string): Balancer_Unzap_V1_1_1destructCall | null {
    return store.get(
      "Balancer_Unzap_V1_1_1destructCall",
      id
    ) as Balancer_Unzap_V1_1_1destructCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1_1inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1_1inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1_1inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_Unzap_V1_1_1inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_Unzap_V1_1_1inCaseTokengetsStuckCall | null {
    return store.get(
      "Balancer_Unzap_V1_1_1inCaseTokengetsStuckCall",
      id
    ) as Balancer_Unzap_V1_1_1inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1_1renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1_1renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1_1renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_Unzap_V1_1_1renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(id: string): Balancer_Unzap_V1_1_1renounceOwnershipCall | null {
    return store.get(
      "Balancer_Unzap_V1_1_1renounceOwnershipCall",
      id
    ) as Balancer_Unzap_V1_1_1renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1_1setnewdzgoodwillAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1_1setnewdzgoodwillAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1_1setnewdzgoodwillAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_Unzap_V1_1_1setnewdzgoodwillAddressCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_Unzap_V1_1_1setnewdzgoodwillAddressCall | null {
    return store.get(
      "Balancer_Unzap_V1_1_1setnewdzgoodwillAddressCall",
      id
    ) as Balancer_Unzap_V1_1_1setnewdzgoodwillAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1_1setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1_1setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1_1setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_Unzap_V1_1_1setnewgoodwillCall", id.toString(), this);
  }

  static load(id: string): Balancer_Unzap_V1_1_1setnewgoodwillCall | null {
    return store.get(
      "Balancer_Unzap_V1_1_1setnewgoodwillCall",
      id
    ) as Balancer_Unzap_V1_1_1setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1_1toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1_1toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1_1toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_Unzap_V1_1_1toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_Unzap_V1_1_1toggleContractActiveCall | null {
    return store.get(
      "Balancer_Unzap_V1_1_1toggleContractActiveCall",
      id
    ) as Balancer_Unzap_V1_1_1toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1_1transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1_1transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1_1transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_Unzap_V1_1_1transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(id: string): Balancer_Unzap_V1_1_1transferOwnershipCall | null {
    return store.get(
      "Balancer_Unzap_V1_1_1transferOwnershipCall",
      id
    ) as Balancer_Unzap_V1_1_1transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_Unzap_V1_1_1updateSlippageCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1_1updateSlippageCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1_1updateSlippageCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_Unzap_V1_1_1updateSlippageCall", id.toString(), this);
  }

  static load(id: string): Balancer_Unzap_V1_1_1updateSlippageCall | null {
    return store.get(
      "Balancer_Unzap_V1_1_1updateSlippageCall",
      id
    ) as Balancer_Unzap_V1_1_1updateSlippageCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_Unzap_V1_1_1withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_Unzap_V1_1_1withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_Unzap_V1_1_1withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_Unzap_V1_1_1withdrawCall", id.toString(), this);
  }

  static load(id: string): Balancer_Unzap_V1_1_1withdrawCall | null {
    return store.get(
      "Balancer_Unzap_V1_1_1withdrawCall",
      id
    ) as Balancer_Unzap_V1_1_1withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV2_ZapInOwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapInOwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapInOwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UniswapV2_ZapInOwnershipTransferredEvent", id.toString(), this);
  }

  static load(id: string): UniswapV2_ZapInOwnershipTransferredEvent | null {
    return store.get(
      "UniswapV2_ZapInOwnershipTransferredEvent",
      id
    ) as UniswapV2_ZapInOwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class UniswapV2_ZapInZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapInZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapInZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UniswapV2_ZapInZapInCall", id.toString(), this);
  }

  static load(id: string): UniswapV2_ZapInZapInCall | null {
    return store.get(
      "UniswapV2_ZapInZapInCall",
      id
    ) as UniswapV2_ZapInZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get slippage(): BigInt {
    let value = this.get("slippage");
    return value.toBigInt();
  }

  set slippage(value: BigInt) {
    this.set("slippage", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class UniswapV2_ZapIndestructCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapIndestructCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapIndestructCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UniswapV2_ZapIndestructCall", id.toString(), this);
  }

  static load(id: string): UniswapV2_ZapIndestructCall | null {
    return store.get(
      "UniswapV2_ZapIndestructCall",
      id
    ) as UniswapV2_ZapIndestructCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV2_ZapIninCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapIninCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapIninCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UniswapV2_ZapIninCaseTokengetsStuckCall", id.toString(), this);
  }

  static load(id: string): UniswapV2_ZapIninCaseTokengetsStuckCall | null {
    return store.get(
      "UniswapV2_ZapIninCaseTokengetsStuckCall",
      id
    ) as UniswapV2_ZapIninCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV2_ZapInrenounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapInrenounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapInrenounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UniswapV2_ZapInrenounceOwnershipCall", id.toString(), this);
  }

  static load(id: string): UniswapV2_ZapInrenounceOwnershipCall | null {
    return store.get(
      "UniswapV2_ZapInrenounceOwnershipCall",
      id
    ) as UniswapV2_ZapInrenounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV2_ZapInsetnewdzgoodwillAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapInsetnewdzgoodwillAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapInsetnewdzgoodwillAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UniswapV2_ZapInsetnewdzgoodwillAddressCall",
      id.toString(),
      this
    );
  }

  static load(id: string): UniswapV2_ZapInsetnewdzgoodwillAddressCall | null {
    return store.get(
      "UniswapV2_ZapInsetnewdzgoodwillAddressCall",
      id
    ) as UniswapV2_ZapInsetnewdzgoodwillAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV2_ZapInsetnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapInsetnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapInsetnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UniswapV2_ZapInsetnewgoodwillCall", id.toString(), this);
  }

  static load(id: string): UniswapV2_ZapInsetnewgoodwillCall | null {
    return store.get(
      "UniswapV2_ZapInsetnewgoodwillCall",
      id
    ) as UniswapV2_ZapInsetnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV2_ZapIntoggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapIntoggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapIntoggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UniswapV2_ZapIntoggleContractActiveCall", id.toString(), this);
  }

  static load(id: string): UniswapV2_ZapIntoggleContractActiveCall | null {
    return store.get(
      "UniswapV2_ZapIntoggleContractActiveCall",
      id
    ) as UniswapV2_ZapIntoggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV2_ZapIntransferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapIntransferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapIntransferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UniswapV2_ZapIntransferOwnershipCall", id.toString(), this);
  }

  static load(id: string): UniswapV2_ZapIntransferOwnershipCall | null {
    return store.get(
      "UniswapV2_ZapIntransferOwnershipCall",
      id
    ) as UniswapV2_ZapIntransferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class UniswapV2_ZapInupdateSlippageCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapInupdateSlippageCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapInupdateSlippageCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UniswapV2_ZapInupdateSlippageCall", id.toString(), this);
  }

  static load(id: string): UniswapV2_ZapInupdateSlippageCall | null {
    return store.get(
      "UniswapV2_ZapInupdateSlippageCall",
      id
    ) as UniswapV2_ZapInupdateSlippageCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV2_ZapInwithdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapInwithdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapInwithdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UniswapV2_ZapInwithdrawCall", id.toString(), this);
  }

  static load(id: string): UniswapV2_ZapInwithdrawCall | null {
    return store.get(
      "UniswapV2_ZapInwithdrawCall",
      id
    ) as UniswapV2_ZapInwithdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1_1OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1_1OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1_1OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V1_1OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V1_1OwnershipTransferredEvent | null {
    return store.get(
      "Balancer_ZapIn_General_V1_1OwnershipTransferredEvent",
      id
    ) as Balancer_ZapIn_General_V1_1OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_ZapIn_General_V1_1ZapinEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1_1ZapinEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1_1ZapinEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V1_1ZapinEvent", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V1_1ZapinEvent | null {
    return store.get(
      "Balancer_ZapIn_General_V1_1ZapinEvent",
      id
    ) as Balancer_ZapIn_General_V1_1ZapinEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1_1EasyZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1_1EasyZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1_1EasyZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V1_1EasyZapInCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V1_1EasyZapInCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1_1EasyZapInCall",
      id
    ) as Balancer_ZapIn_General_V1_1EasyZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get tokensBought(): BigInt {
    let value = this.get("tokensBought");
    return value.toBigInt();
  }

  set tokensBought(value: BigInt) {
    this.set("tokensBought", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1_1ZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1_1ZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1_1ZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V1_1ZapInCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V1_1ZapInCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1_1ZapInCall",
      id
    ) as Balancer_ZapIn_General_V1_1ZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get tokensBought(): BigInt {
    let value = this.get("tokensBought");
    return value.toBigInt();
  }

  set tokensBought(value: BigInt) {
    this.set("tokensBought", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1_1destructCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1_1destructCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1_1destructCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V1_1destructCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V1_1destructCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1_1destructCall",
      id
    ) as Balancer_ZapIn_General_V1_1destructCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1_1inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1_1inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1_1inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V1_1inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V1_1inCaseTokengetsStuckCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1_1inCaseTokengetsStuckCall",
      id
    ) as Balancer_ZapIn_General_V1_1inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1_1renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1_1renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1_1renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V1_1renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V1_1renounceOwnershipCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1_1renounceOwnershipCall",
      id
    ) as Balancer_ZapIn_General_V1_1renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1_1setnewdzgoodwillAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1_1setnewdzgoodwillAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1_1setnewdzgoodwillAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V1_1setnewdzgoodwillAddressCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V1_1setnewdzgoodwillAddressCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1_1setnewdzgoodwillAddressCall",
      id
    ) as Balancer_ZapIn_General_V1_1setnewdzgoodwillAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1_1setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1_1setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1_1setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V1_1setnewgoodwillCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V1_1setnewgoodwillCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1_1setnewgoodwillCall",
      id
    ) as Balancer_ZapIn_General_V1_1setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1_1toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1_1toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1_1toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V1_1toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V1_1toggleContractActiveCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1_1toggleContractActiveCall",
      id
    ) as Balancer_ZapIn_General_V1_1toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V1_1transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1_1transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1_1transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V1_1transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V1_1transferOwnershipCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1_1transferOwnershipCall",
      id
    ) as Balancer_ZapIn_General_V1_1transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_ZapIn_General_V1_1withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V1_1withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V1_1withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V1_1withdrawCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V1_1withdrawCall | null {
    return store.get(
      "Balancer_ZapIn_General_V1_1withdrawCall",
      id
    ) as Balancer_ZapIn_General_V1_1withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Uni_V1_V2_PipeOwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_V1_V2_PipeOwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_V1_V2_PipeOwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_V1_V2_PipeOwnershipTransferredEvent", id.toString(), this);
  }

  static load(id: string): Uni_V1_V2_PipeOwnershipTransferredEvent | null {
    return store.get(
      "Uni_V1_V2_PipeOwnershipTransferredEvent",
      id
    ) as Uni_V1_V2_PipeOwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Uni_V1_V2_PipeliquidityTokensQtyEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_V1_V2_PipeliquidityTokensQtyEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_V1_V2_PipeliquidityTokensQtyEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_V1_V2_PipeliquidityTokensQtyEvent", id.toString(), this);
  }

  static load(id: string): Uni_V1_V2_PipeliquidityTokensQtyEvent | null {
    return store.get(
      "Uni_V1_V2_PipeliquidityTokensQtyEvent",
      id
    ) as Uni_V1_V2_PipeliquidityTokensQtyEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get param0(): BigInt {
    let value = this.get("param0");
    return value.toBigInt();
  }

  set param0(value: BigInt) {
    this.set("param0", Value.fromBigInt(value));
  }

  get param1(): Bytes {
    let value = this.get("param1");
    return value.toBytes();
  }

  set param1(value: Bytes) {
    this.set("param1", Value.fromBytes(value));
  }

  get param2(): BigInt {
    let value = this.get("param2");
    return value.toBigInt();
  }

  set param2(value: BigInt) {
    this.set("param2", Value.fromBigInt(value));
  }
}

export class Uni_V1_V2_PipeV1toV2PipeCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_V1_V2_PipeV1toV2PipeCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_V1_V2_PipeV1toV2PipeCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_V1_V2_PipeV1toV2PipeCall", id.toString(), this);
  }

  static load(id: string): Uni_V1_V2_PipeV1toV2PipeCall | null {
    return store.get(
      "Uni_V1_V2_PipeV1toV2PipeCall",
      id
    ) as Uni_V1_V2_PipeV1toV2PipeCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get fromTokenAddress(): Bytes {
    let value = this.get("fromTokenAddress");
    return value.toBytes();
  }

  set fromTokenAddress(value: Bytes) {
    this.set("fromTokenAddress", Value.fromBytes(value));
  }

  get uniV1Amount(): BigInt {
    let value = this.get("uniV1Amount");
    return value.toBigInt();
  }

  set uniV1Amount(value: BigInt) {
    this.set("uniV1Amount", Value.fromBigInt(value));
  }

  get toTokenAddress(): Bytes {
    let value = this.get("toTokenAddress");
    return value.toBytes();
  }

  set toTokenAddress(value: Bytes) {
    this.set("toTokenAddress", Value.fromBytes(value));
  }

  get toWhomToIssue(): Bytes {
    let value = this.get("toWhomToIssue");
    return value.toBytes();
  }

  set toWhomToIssue(value: Bytes) {
    this.set("toWhomToIssue", Value.fromBytes(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class Uni_V1_V2_PipedestructCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_V1_V2_PipedestructCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_V1_V2_PipedestructCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_V1_V2_PipedestructCall", id.toString(), this);
  }

  static load(id: string): Uni_V1_V2_PipedestructCall | null {
    return store.get(
      "Uni_V1_V2_PipedestructCall",
      id
    ) as Uni_V1_V2_PipedestructCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Uni_V1_V2_PipeinCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_V1_V2_PipeinCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_V1_V2_PipeinCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_V1_V2_PipeinCaseTokengetsStuckCall", id.toString(), this);
  }

  static load(id: string): Uni_V1_V2_PipeinCaseTokengetsStuckCall | null {
    return store.get(
      "Uni_V1_V2_PipeinCaseTokengetsStuckCall",
      id
    ) as Uni_V1_V2_PipeinCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Uni_V1_V2_PiperenounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_V1_V2_PiperenounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_V1_V2_PiperenounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_V1_V2_PiperenounceOwnershipCall", id.toString(), this);
  }

  static load(id: string): Uni_V1_V2_PiperenounceOwnershipCall | null {
    return store.get(
      "Uni_V1_V2_PiperenounceOwnershipCall",
      id
    ) as Uni_V1_V2_PiperenounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Uni_V1_V2_PipesetnewdzgoodwillAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_V1_V2_PipesetnewdzgoodwillAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_V1_V2_PipesetnewdzgoodwillAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_V1_V2_PipesetnewdzgoodwillAddressCall", id.toString(), this);
  }

  static load(id: string): Uni_V1_V2_PipesetnewdzgoodwillAddressCall | null {
    return store.get(
      "Uni_V1_V2_PipesetnewdzgoodwillAddressCall",
      id
    ) as Uni_V1_V2_PipesetnewdzgoodwillAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Uni_V1_V2_PipesetnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_V1_V2_PipesetnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_V1_V2_PipesetnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_V1_V2_PipesetnewgoodwillCall", id.toString(), this);
  }

  static load(id: string): Uni_V1_V2_PipesetnewgoodwillCall | null {
    return store.get(
      "Uni_V1_V2_PipesetnewgoodwillCall",
      id
    ) as Uni_V1_V2_PipesetnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Uni_V1_V2_PipetoggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_V1_V2_PipetoggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_V1_V2_PipetoggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_V1_V2_PipetoggleContractActiveCall", id.toString(), this);
  }

  static load(id: string): Uni_V1_V2_PipetoggleContractActiveCall | null {
    return store.get(
      "Uni_V1_V2_PipetoggleContractActiveCall",
      id
    ) as Uni_V1_V2_PipetoggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Uni_V1_V2_PipetransferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_V1_V2_PipetransferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_V1_V2_PipetransferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_V1_V2_PipetransferOwnershipCall", id.toString(), this);
  }

  static load(id: string): Uni_V1_V2_PipetransferOwnershipCall | null {
    return store.get(
      "Uni_V1_V2_PipetransferOwnershipCall",
      id
    ) as Uni_V1_V2_PipetransferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Uni_V1_V2_PipewithdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Uni_V1_V2_PipewithdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Uni_V1_V2_PipewithdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Uni_V1_V2_PipewithdrawCall", id.toString(), this);
  }

  static load(id: string): Uni_V1_V2_PipewithdrawCall | null {
    return store.get(
      "Uni_V1_V2_PipewithdrawCall",
      id
    ) as Uni_V1_V2_PipewithdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V2OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V2OwnershipTransferredEvent | null {
    return store.get(
      "Balancer_ZapIn_General_V2OwnershipTransferredEvent",
      id
    ) as Balancer_ZapIn_General_V2OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_ZapIn_General_V2ZapinEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2ZapinEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2ZapinEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V2ZapinEvent", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V2ZapinEvent | null {
    return store.get(
      "Balancer_ZapIn_General_V2ZapinEvent",
      id
    ) as Balancer_ZapIn_General_V2ZapinEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2EasyZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2EasyZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2EasyZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V2EasyZapInCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V2EasyZapInCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2EasyZapInCall",
      id
    ) as Balancer_ZapIn_General_V2EasyZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get tokensBought(): BigInt {
    let value = this.get("tokensBought");
    return value.toBigInt();
  }

  set tokensBought(value: BigInt) {
    this.set("tokensBought", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2ZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2ZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2ZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V2ZapInCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V2ZapInCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2ZapInCall",
      id
    ) as Balancer_ZapIn_General_V2ZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get tokensBought(): BigInt {
    let value = this.get("tokensBought");
    return value.toBigInt();
  }

  set tokensBought(value: BigInt) {
    this.set("tokensBought", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2destructCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2destructCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2destructCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V2destructCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V2destructCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2destructCall",
      id
    ) as Balancer_ZapIn_General_V2destructCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V2inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V2inCaseTokengetsStuckCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2inCaseTokengetsStuckCall",
      id
    ) as Balancer_ZapIn_General_V2inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V2renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V2renounceOwnershipCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2renounceOwnershipCall",
      id
    ) as Balancer_ZapIn_General_V2renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2setnewdzgoodwillAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2setnewdzgoodwillAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2setnewdzgoodwillAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V2setnewdzgoodwillAddressCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V2setnewdzgoodwillAddressCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2setnewdzgoodwillAddressCall",
      id
    ) as Balancer_ZapIn_General_V2setnewdzgoodwillAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V2setnewgoodwillCall",
      id.toString(),
      this
    );
  }

  static load(id: string): Balancer_ZapIn_General_V2setnewgoodwillCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2setnewgoodwillCall",
      id
    ) as Balancer_ZapIn_General_V2setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V2toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V2toggleContractActiveCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2toggleContractActiveCall",
      id
    ) as Balancer_ZapIn_General_V2toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V2transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V2transferOwnershipCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2transferOwnershipCall",
      id
    ) as Balancer_ZapIn_General_V2transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_ZapIn_General_V2withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V2withdrawCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V2withdrawCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2withdrawCall",
      id
    ) as Balancer_ZapIn_General_V2withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapOut_General_V2OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapOut_General_V2OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapOut_General_V2OwnershipTransferredEvent | null {
    return store.get(
      "Balancer_ZapOut_General_V2OwnershipTransferredEvent",
      id
    ) as Balancer_ZapOut_General_V2OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_ZapOut_General_V2ZapoutEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2ZapoutEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2ZapoutEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapOut_General_V2ZapoutEvent", id.toString(), this);
  }

  static load(id: string): Balancer_ZapOut_General_V2ZapoutEvent | null {
    return store.get(
      "Balancer_ZapOut_General_V2ZapoutEvent",
      id
    ) as Balancer_ZapOut_General_V2ZapoutEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapOut_General_V2EasyZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2EasyZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2EasyZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapOut_General_V2EasyZapOutCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapOut_General_V2EasyZapOutCall | null {
    return store.get(
      "Balancer_ZapOut_General_V2EasyZapOutCall",
      id
    ) as Balancer_ZapOut_General_V2EasyZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class Balancer_ZapOut_General_V2ZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2ZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2ZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapOut_General_V2ZapOutCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapOut_General_V2ZapOutCall | null {
    return store.get(
      "Balancer_ZapOut_General_V2ZapOutCall",
      id
    ) as Balancer_ZapOut_General_V2ZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class Balancer_ZapOut_General_V2inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapOut_General_V2inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapOut_General_V2inCaseTokengetsStuckCall | null {
    return store.get(
      "Balancer_ZapOut_General_V2inCaseTokengetsStuckCall",
      id
    ) as Balancer_ZapOut_General_V2inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapOut_General_V2renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapOut_General_V2renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapOut_General_V2renounceOwnershipCall | null {
    return store.get(
      "Balancer_ZapOut_General_V2renounceOwnershipCall",
      id
    ) as Balancer_ZapOut_General_V2renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapOut_General_V2setnewdzgoodwillAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2setnewdzgoodwillAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2setnewdzgoodwillAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapOut_General_V2setnewdzgoodwillAddressCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapOut_General_V2setnewdzgoodwillAddressCall | null {
    return store.get(
      "Balancer_ZapOut_General_V2setnewdzgoodwillAddressCall",
      id
    ) as Balancer_ZapOut_General_V2setnewdzgoodwillAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapOut_General_V2setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapOut_General_V2setnewgoodwillCall",
      id.toString(),
      this
    );
  }

  static load(id: string): Balancer_ZapOut_General_V2setnewgoodwillCall | null {
    return store.get(
      "Balancer_ZapOut_General_V2setnewgoodwillCall",
      id
    ) as Balancer_ZapOut_General_V2setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapOut_General_V2toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapOut_General_V2toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapOut_General_V2toggleContractActiveCall | null {
    return store.get(
      "Balancer_ZapOut_General_V2toggleContractActiveCall",
      id
    ) as Balancer_ZapOut_General_V2toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapOut_General_V2transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapOut_General_V2transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapOut_General_V2transferOwnershipCall | null {
    return store.get(
      "Balancer_ZapOut_General_V2transferOwnershipCall",
      id
    ) as Balancer_ZapOut_General_V2transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_ZapOut_General_V2withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapOut_General_V2withdrawCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapOut_General_V2withdrawCall | null {
    return store.get(
      "Balancer_ZapOut_General_V2withdrawCall",
      id
    ) as Balancer_ZapOut_General_V2withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_General_ZapOut_V2OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Curve_General_ZapOut_V2OwnershipTransferredEvent | null {
    return store.get(
      "Curve_General_ZapOut_V2OwnershipTransferredEvent",
      id
    ) as Curve_General_ZapOut_V2OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Curve_General_ZapOut_V2ZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2ZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2ZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_General_ZapOut_V2ZapOutCall", id.toString(), this);
  }

  static load(id: string): Curve_General_ZapOut_V2ZapOutCall | null {
    return store.get(
      "Curve_General_ZapOut_V2ZapOutCall",
      id
    ) as Curve_General_ZapOut_V2ZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get ToTokensBought(): BigInt {
    let value = this.get("ToTokensBought");
    return value.toBigInt();
  }

  set ToTokensBought(value: BigInt) {
    this.set("ToTokensBought", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2ZapoutToUnderlyingCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2ZapoutToUnderlyingCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2ZapoutToUnderlyingCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_General_ZapOut_V2ZapoutToUnderlyingCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Curve_General_ZapOut_V2ZapoutToUnderlyingCall | null {
    return store.get(
      "Curve_General_ZapOut_V2ZapoutToUnderlyingCall",
      id
    ) as Curve_General_ZapOut_V2ZapoutToUnderlyingCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2token2EthCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2token2EthCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2token2EthCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_General_ZapOut_V2token2EthCall", id.toString(), this);
  }

  static load(id: string): Curve_General_ZapOut_V2token2EthCall | null {
    return store.get(
      "Curve_General_ZapOut_V2token2EthCall",
      id
    ) as Curve_General_ZapOut_V2token2EthCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get tokens2Trade(): BigInt {
    let value = this.get("tokens2Trade");
    return value.toBigInt();
  }

  set tokens2Trade(value: BigInt) {
    this.set("tokens2Trade", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2token2TokenCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2token2TokenCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2token2TokenCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_General_ZapOut_V2token2TokenCall", id.toString(), this);
  }

  static load(id: string): Curve_General_ZapOut_V2token2TokenCall | null {
    return store.get(
      "Curve_General_ZapOut_V2token2TokenCall",
      id
    ) as Curve_General_ZapOut_V2token2TokenCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get tokens2Trade(): BigInt {
    let value = this.get("tokens2Trade");
    return value.toBigInt();
  }

  set tokens2Trade(value: BigInt) {
    this.set("tokens2Trade", Value.fromBigInt(value));
  }

  get tokenBought(): BigInt {
    let value = this.get("tokenBought");
    return value.toBigInt();
  }

  set tokenBought(value: BigInt) {
    this.set("tokenBought", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2addCRVTokenCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2addCRVTokenCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2addCRVTokenCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_General_ZapOut_V2addCRVTokenCall", id.toString(), this);
  }

  static load(id: string): Curve_General_ZapOut_V2addCRVTokenCall | null {
    return store.get(
      "Curve_General_ZapOut_V2addCRVTokenCall",
      id
    ) as Curve_General_ZapOut_V2addCRVTokenCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2addCTokenCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2addCTokenCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2addCTokenCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_General_ZapOut_V2addCTokenCall", id.toString(), this);
  }

  static load(id: string): Curve_General_ZapOut_V2addCTokenCall | null {
    return store.get(
      "Curve_General_ZapOut_V2addCTokenCall",
      id
    ) as Curve_General_ZapOut_V2addCTokenCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2addYTokenCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2addYTokenCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2addYTokenCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_General_ZapOut_V2addYTokenCall", id.toString(), this);
  }

  static load(id: string): Curve_General_ZapOut_V2addYTokenCall | null {
    return store.get(
      "Curve_General_ZapOut_V2addYTokenCall",
      id
    ) as Curve_General_ZapOut_V2addYTokenCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2approveTokenCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2approveTokenCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2approveTokenCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_General_ZapOut_V2approveTokenCall", id.toString(), this);
  }

  static load(id: string): Curve_General_ZapOut_V2approveTokenCall | null {
    return store.get(
      "Curve_General_ZapOut_V2approveTokenCall",
      id
    ) as Curve_General_ZapOut_V2approveTokenCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_General_ZapOut_V2inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Curve_General_ZapOut_V2inCaseTokengetsStuckCall | null {
    return store.get(
      "Curve_General_ZapOut_V2inCaseTokengetsStuckCall",
      id
    ) as Curve_General_ZapOut_V2inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_General_ZapOut_V2renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(id: string): Curve_General_ZapOut_V2renounceOwnershipCall | null {
    return store.get(
      "Curve_General_ZapOut_V2renounceOwnershipCall",
      id
    ) as Curve_General_ZapOut_V2renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2setCRVTokenAddressesCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2setCRVTokenAddressesCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2setCRVTokenAddressesCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_General_ZapOut_V2setCRVTokenAddressesCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Curve_General_ZapOut_V2setCRVTokenAddressesCall | null {
    return store.get(
      "Curve_General_ZapOut_V2setCRVTokenAddressesCall",
      id
    ) as Curve_General_ZapOut_V2setCRVTokenAddressesCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2setnewdzgoodwillAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2setnewdzgoodwillAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2setnewdzgoodwillAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_General_ZapOut_V2setnewdzgoodwillAddressCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Curve_General_ZapOut_V2setnewdzgoodwillAddressCall | null {
    return store.get(
      "Curve_General_ZapOut_V2setnewdzgoodwillAddressCall",
      id
    ) as Curve_General_ZapOut_V2setnewdzgoodwillAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_General_ZapOut_V2setnewgoodwillCall", id.toString(), this);
  }

  static load(id: string): Curve_General_ZapOut_V2setnewgoodwillCall | null {
    return store.get(
      "Curve_General_ZapOut_V2setnewgoodwillCall",
      id
    ) as Curve_General_ZapOut_V2setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2setnewsUSDTokenAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2setnewsUSDTokenAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2setnewsUSDTokenAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_General_ZapOut_V2setnewsUSDTokenAddressCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Curve_General_ZapOut_V2setnewsUSDTokenAddressCall | null {
    return store.get(
      "Curve_General_ZapOut_V2setnewsUSDTokenAddressCall",
      id
    ) as Curve_General_ZapOut_V2setnewsUSDTokenAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2setcTokensCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2setcTokensCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2setcTokensCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_General_ZapOut_V2setcTokensCall", id.toString(), this);
  }

  static load(id: string): Curve_General_ZapOut_V2setcTokensCall | null {
    return store.get(
      "Curve_General_ZapOut_V2setcTokensCall",
      id
    ) as Curve_General_ZapOut_V2setcTokensCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2setyTokensCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2setyTokensCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2setyTokensCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_General_ZapOut_V2setyTokensCall", id.toString(), this);
  }

  static load(id: string): Curve_General_ZapOut_V2setyTokensCall | null {
    return store.get(
      "Curve_General_ZapOut_V2setyTokensCall",
      id
    ) as Curve_General_ZapOut_V2setyTokensCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_General_ZapOut_V2toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Curve_General_ZapOut_V2toggleContractActiveCall | null {
    return store.get(
      "Curve_General_ZapOut_V2toggleContractActiveCall",
      id
    ) as Curve_General_ZapOut_V2toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_General_ZapOut_V2transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_General_ZapOut_V2transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(id: string): Curve_General_ZapOut_V2transferOwnershipCall | null {
    return store.get(
      "Curve_General_ZapOut_V2transferOwnershipCall",
      id
    ) as Curve_General_ZapOut_V2transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Curve_General_ZapOut_V2withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_General_ZapOut_V2withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_General_ZapOut_V2withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_General_ZapOut_V2withdrawCall", id.toString(), this);
  }

  static load(id: string): Curve_General_ZapOut_V2withdrawCall | null {
    return store.get(
      "Curve_General_ZapOut_V2withdrawCall",
      id
    ) as Curve_General_ZapOut_V2withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV1_ZapOut_General_V2OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV1_ZapOut_General_V2OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV1_ZapOut_General_V2OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UniswapV1_ZapOut_General_V2OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): UniswapV1_ZapOut_General_V2OwnershipTransferredEvent | null {
    return store.get(
      "UniswapV1_ZapOut_General_V2OwnershipTransferredEvent",
      id
    ) as UniswapV1_ZapOut_General_V2OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class UniswapV1_ZapOut_General_V2detailsEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV1_ZapOut_General_V2detailsEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV1_ZapOut_General_V2detailsEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UniswapV1_ZapOut_General_V2detailsEvent", id.toString(), this);
  }

  static load(id: string): UniswapV1_ZapOut_General_V2detailsEvent | null {
    return store.get(
      "UniswapV1_ZapOut_General_V2detailsEvent",
      id
    ) as UniswapV1_ZapOut_General_V2detailsEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get ExchangeAddress(): Bytes {
    let value = this.get("ExchangeAddress");
    return value.toBytes();
  }

  set ExchangeAddress(value: Bytes) {
    this.set("ExchangeAddress", Value.fromBytes(value));
  }

  get TokenAdddress(): Bytes {
    let value = this.get("TokenAdddress");
    return value.toBytes();
  }

  set TokenAdddress(value: Bytes) {
    this.set("TokenAdddress", Value.fromBytes(value));
  }

  get LiqRed(): BigInt {
    let value = this.get("LiqRed");
    return value.toBigInt();
  }

  set LiqRed(value: BigInt) {
    this.set("LiqRed", Value.fromBigInt(value));
  }

  get ethRec(): BigInt {
    let value = this.get("ethRec");
    return value.toBigInt();
  }

  set ethRec(value: BigInt) {
    this.set("ethRec", Value.fromBigInt(value));
  }

  get tokenRec(): BigInt {
    let value = this.get("tokenRec");
    return value.toBigInt();
  }

  set tokenRec(value: BigInt) {
    this.set("tokenRec", Value.fromBigInt(value));
  }

  get func(): Bytes {
    let value = this.get("func");
    return value.toBytes();
  }

  set func(value: Bytes) {
    this.set("func", Value.fromBytes(value));
  }
}

export class UniswapV1_ZapOut_General_V2LetsWithdrawonlyERCCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV1_ZapOut_General_V2LetsWithdrawonlyERCCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV1_ZapOut_General_V2LetsWithdrawonlyERCCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UniswapV1_ZapOut_General_V2LetsWithdrawonlyERCCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): UniswapV1_ZapOut_General_V2LetsWithdrawonlyERCCall | null {
    return store.get(
      "UniswapV1_ZapOut_General_V2LetsWithdrawonlyERCCall",
      id
    ) as UniswapV1_ZapOut_General_V2LetsWithdrawonlyERCCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get LiquidityTokenSold(): BigInt {
    let value = this.get("LiquidityTokenSold");
    return value.toBigInt();
  }

  set LiquidityTokenSold(value: BigInt) {
    this.set("LiquidityTokenSold", Value.fromBigInt(value));
  }

  get value0(): boolean {
    let value = this.get("value0");
    return value.toBoolean();
  }

  set value0(value: boolean) {
    this.set("value0", Value.fromBoolean(value));
  }
}

export class UniswapV1_ZapOut_General_V2LetsWithdrawonlyETHCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV1_ZapOut_General_V2LetsWithdrawonlyETHCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV1_ZapOut_General_V2LetsWithdrawonlyETHCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UniswapV1_ZapOut_General_V2LetsWithdrawonlyETHCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): UniswapV1_ZapOut_General_V2LetsWithdrawonlyETHCall | null {
    return store.get(
      "UniswapV1_ZapOut_General_V2LetsWithdrawonlyETHCall",
      id
    ) as UniswapV1_ZapOut_General_V2LetsWithdrawonlyETHCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get LiquidityTokenSold(): BigInt {
    let value = this.get("LiquidityTokenSold");
    return value.toBigInt();
  }

  set LiquidityTokenSold(value: BigInt) {
    this.set("LiquidityTokenSold", Value.fromBigInt(value));
  }

  get value0(): boolean {
    let value = this.get("value0");
    return value.toBoolean();
  }

  set value0(value: boolean) {
    this.set("value0", Value.fromBoolean(value));
  }
}

export class UniswapV1_ZapOut_General_V2inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV1_ZapOut_General_V2inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV1_ZapOut_General_V2inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UniswapV1_ZapOut_General_V2inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): UniswapV1_ZapOut_General_V2inCaseTokengetsStuckCall | null {
    return store.get(
      "UniswapV1_ZapOut_General_V2inCaseTokengetsStuckCall",
      id
    ) as UniswapV1_ZapOut_General_V2inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV1_ZapOut_General_V2renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV1_ZapOut_General_V2renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV1_ZapOut_General_V2renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UniswapV1_ZapOut_General_V2renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): UniswapV1_ZapOut_General_V2renounceOwnershipCall | null {
    return store.get(
      "UniswapV1_ZapOut_General_V2renounceOwnershipCall",
      id
    ) as UniswapV1_ZapOut_General_V2renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV1_ZapOut_General_V2setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV1_ZapOut_General_V2setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV1_ZapOut_General_V2setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UniswapV1_ZapOut_General_V2setnewgoodwillCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): UniswapV1_ZapOut_General_V2setnewgoodwillCall | null {
    return store.get(
      "UniswapV1_ZapOut_General_V2setnewgoodwillCall",
      id
    ) as UniswapV1_ZapOut_General_V2setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV1_ZapOut_General_V2toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV1_ZapOut_General_V2toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV1_ZapOut_General_V2toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UniswapV1_ZapOut_General_V2toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): UniswapV1_ZapOut_General_V2toggleContractActiveCall | null {
    return store.get(
      "UniswapV1_ZapOut_General_V2toggleContractActiveCall",
      id
    ) as UniswapV1_ZapOut_General_V2toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV1_ZapOut_General_V2transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV1_ZapOut_General_V2transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV1_ZapOut_General_V2transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UniswapV1_ZapOut_General_V2transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): UniswapV1_ZapOut_General_V2transferOwnershipCall | null {
    return store.get(
      "UniswapV1_ZapOut_General_V2transferOwnershipCall",
      id
    ) as UniswapV1_ZapOut_General_V2transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class UniswapV1_ZapOut_General_V2withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV1_ZapOut_General_V2withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV1_ZapOut_General_V2withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UniswapV1_ZapOut_General_V2withdrawCall", id.toString(), this);
  }

  static load(id: string): UniswapV1_ZapOut_General_V2withdrawCall | null {
    return store.get(
      "UniswapV1_ZapOut_General_V2withdrawCall",
      id
    ) as UniswapV1_ZapOut_General_V2withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_1OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_1OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_1OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_1OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_1OwnershipTransferredEvent | null {
    return store.get(
      "yVault_ZapInOut_General_V1_1OwnershipTransferredEvent",
      id
    ) as yVault_ZapInOut_General_V1_1OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_1ZapinEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_1ZapinEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_1ZapinEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_1ZapinEvent", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_1ZapinEvent | null {
    return store.get(
      "yVault_ZapInOut_General_V1_1ZapinEvent",
      id
    ) as yVault_ZapInOut_General_V1_1ZapinEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_1ZapoutEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_1ZapoutEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_1ZapoutEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_1ZapoutEvent", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_1ZapoutEvent | null {
    return store.get(
      "yVault_ZapInOut_General_V1_1ZapoutEvent",
      id
    ) as yVault_ZapInOut_General_V1_1ZapoutEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_1ZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_1ZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_1ZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_1ZapInCall", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_1ZapInCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_1ZapInCall",
      id
    ) as yVault_ZapInOut_General_V1_1ZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_1ZapOutToUnderlyingCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_1ZapOutToUnderlyingCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_1ZapOutToUnderlyingCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_1ZapOutToUnderlyingCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_1ZapOutToUnderlyingCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_1ZapOutToUnderlyingCall",
      id
    ) as yVault_ZapInOut_General_V1_1ZapOutToUnderlyingCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_1addNewYVaultCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_1addNewYVaultCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_1addNewYVaultCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_1addNewYVaultCall",
      id.toString(),
      this
    );
  }

  static load(id: string): yVault_ZapInOut_General_V1_1addNewYVaultCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_1addNewYVaultCall",
      id
    ) as yVault_ZapInOut_General_V1_1addNewYVaultCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_1inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_1inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_1inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_1inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_1inCaseTokengetsStuckCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_1inCaseTokengetsStuckCall",
      id
    ) as yVault_ZapInOut_General_V1_1inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_1renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_1renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_1renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_1renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_1renounceOwnershipCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_1renounceOwnershipCall",
      id
    ) as yVault_ZapInOut_General_V1_1renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_1setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_1setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_1setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_1setnewgoodwillCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_1setnewgoodwillCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_1setnewgoodwillCall",
      id
    ) as yVault_ZapInOut_General_V1_1setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_1toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_1toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_1toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_1toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_1toggleContractActiveCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_1toggleContractActiveCall",
      id
    ) as yVault_ZapInOut_General_V1_1toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_1transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_1transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_1transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_1transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_1transferOwnershipCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_1transferOwnershipCall",
      id
    ) as yVault_ZapInOut_General_V1_1transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_1updateCurveZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_1updateCurveZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_1updateCurveZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_1updateCurveZapInCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_1updateCurveZapInCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_1updateCurveZapInCall",
      id
    ) as yVault_ZapInOut_General_V1_1updateCurveZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get CurveZapInGeneralAddress(): Bytes {
    let value = this.get("CurveZapInGeneralAddress");
    return value.toBytes();
  }

  set CurveZapInGeneralAddress(value: Bytes) {
    this.set("CurveZapInGeneralAddress", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_1withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_1withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_1withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_1withdrawCall", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_1withdrawCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_1withdrawCall",
      id
    ) as yVault_ZapInOut_General_V1_1withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapOut_General_V2_2OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2_2OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2_2OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapOut_General_V2_2OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapOut_General_V2_2OwnershipTransferredEvent | null {
    return store.get(
      "Balancer_ZapOut_General_V2_2OwnershipTransferredEvent",
      id
    ) as Balancer_ZapOut_General_V2_2OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_ZapOut_General_V2_2ZapoutEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2_2ZapoutEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2_2ZapoutEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapOut_General_V2_2ZapoutEvent", id.toString(), this);
  }

  static load(id: string): Balancer_ZapOut_General_V2_2ZapoutEvent | null {
    return store.get(
      "Balancer_ZapOut_General_V2_2ZapoutEvent",
      id
    ) as Balancer_ZapOut_General_V2_2ZapoutEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapOut_General_V2_2EasyZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2_2EasyZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2_2EasyZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapOut_General_V2_2EasyZapOutCall",
      id.toString(),
      this
    );
  }

  static load(id: string): Balancer_ZapOut_General_V2_2EasyZapOutCall | null {
    return store.get(
      "Balancer_ZapOut_General_V2_2EasyZapOutCall",
      id
    ) as Balancer_ZapOut_General_V2_2EasyZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class Balancer_ZapOut_General_V2_2inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2_2inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2_2inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapOut_General_V2_2inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapOut_General_V2_2inCaseTokengetsStuckCall | null {
    return store.get(
      "Balancer_ZapOut_General_V2_2inCaseTokengetsStuckCall",
      id
    ) as Balancer_ZapOut_General_V2_2inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapOut_General_V2_2renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2_2renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2_2renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapOut_General_V2_2renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapOut_General_V2_2renounceOwnershipCall | null {
    return store.get(
      "Balancer_ZapOut_General_V2_2renounceOwnershipCall",
      id
    ) as Balancer_ZapOut_General_V2_2renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapOut_General_V2_2setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2_2setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2_2setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapOut_General_V2_2setnewgoodwillCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapOut_General_V2_2setnewgoodwillCall | null {
    return store.get(
      "Balancer_ZapOut_General_V2_2setnewgoodwillCall",
      id
    ) as Balancer_ZapOut_General_V2_2setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapOut_General_V2_2toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2_2toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2_2toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapOut_General_V2_2toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapOut_General_V2_2toggleContractActiveCall | null {
    return store.get(
      "Balancer_ZapOut_General_V2_2toggleContractActiveCall",
      id
    ) as Balancer_ZapOut_General_V2_2toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapOut_General_V2_2transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2_2transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2_2transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapOut_General_V2_2transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapOut_General_V2_2transferOwnershipCall | null {
    return store.get(
      "Balancer_ZapOut_General_V2_2transferOwnershipCall",
      id
    ) as Balancer_ZapOut_General_V2_2transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_ZapOut_General_V2_2withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapOut_General_V2_2withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapOut_General_V2_2withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapOut_General_V2_2withdrawCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapOut_General_V2_2withdrawCall | null {
    return store.get(
      "Balancer_ZapOut_General_V2_2withdrawCall",
      id
    ) as Balancer_ZapOut_General_V2_2withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_2OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_2OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_2OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_2OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_2OwnershipTransferredEvent | null {
    return store.get(
      "yVault_ZapInOut_General_V1_2OwnershipTransferredEvent",
      id
    ) as yVault_ZapInOut_General_V1_2OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_2ZapinEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_2ZapinEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_2ZapinEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_2ZapinEvent", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_2ZapinEvent | null {
    return store.get(
      "yVault_ZapInOut_General_V1_2ZapinEvent",
      id
    ) as yVault_ZapInOut_General_V1_2ZapinEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_2ZapoutEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_2ZapoutEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_2ZapoutEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_2ZapoutEvent", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_2ZapoutEvent | null {
    return store.get(
      "yVault_ZapInOut_General_V1_2ZapoutEvent",
      id
    ) as yVault_ZapInOut_General_V1_2ZapoutEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_2ZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_2ZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_2ZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_2ZapInCall", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_2ZapInCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_2ZapInCall",
      id
    ) as yVault_ZapInOut_General_V1_2ZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_2ZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_2ZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_2ZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_2ZapOutCall", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_2ZapOutCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_2ZapOutCall",
      id
    ) as yVault_ZapInOut_General_V1_2ZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_2inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_2inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_2inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_2inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_2inCaseTokengetsStuckCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_2inCaseTokengetsStuckCall",
      id
    ) as yVault_ZapInOut_General_V1_2inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_2renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_2renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_2renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_2renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_2renounceOwnershipCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_2renounceOwnershipCall",
      id
    ) as yVault_ZapInOut_General_V1_2renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_2setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_2setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_2setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_2setnewgoodwillCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_2setnewgoodwillCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_2setnewgoodwillCall",
      id
    ) as yVault_ZapInOut_General_V1_2setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_2toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_2toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_2toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_2toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_2toggleContractActiveCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_2toggleContractActiveCall",
      id
    ) as yVault_ZapInOut_General_V1_2toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_2transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_2transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_2transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_2transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_2transferOwnershipCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_2transferOwnershipCall",
      id
    ) as yVault_ZapInOut_General_V1_2transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_2updateCurveZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_2updateCurveZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_2updateCurveZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_2updateCurveZapInCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_2updateCurveZapInCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_2updateCurveZapInCall",
      id
    ) as yVault_ZapInOut_General_V1_2updateCurveZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get CurveZapInGeneralAddress(): Bytes {
    let value = this.get("CurveZapInGeneralAddress");
    return value.toBytes();
  }

  set CurveZapInGeneralAddress(value: Bytes) {
    this.set("CurveZapInGeneralAddress", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_2updateCurveZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_2updateCurveZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_2updateCurveZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_2updateCurveZapOutCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_2updateCurveZapOutCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_2updateCurveZapOutCall",
      id
    ) as yVault_ZapInOut_General_V1_2updateCurveZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get CurveZapOutGeneralAddress(): Bytes {
    let value = this.get("CurveZapOutGeneralAddress");
    return value.toBytes();
  }

  set CurveZapOutGeneralAddress(value: Bytes) {
    this.set("CurveZapOutGeneralAddress", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_2withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_2withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_2withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_2withdrawCall", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_2withdrawCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_2withdrawCall",
      id
    ) as yVault_ZapInOut_General_V1_2withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_3OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_3OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_3OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_3OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_3OwnershipTransferredEvent | null {
    return store.get(
      "yVault_ZapInOut_General_V1_3OwnershipTransferredEvent",
      id
    ) as yVault_ZapInOut_General_V1_3OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_3ZapinEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_3ZapinEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_3ZapinEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_3ZapinEvent", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_3ZapinEvent | null {
    return store.get(
      "yVault_ZapInOut_General_V1_3ZapinEvent",
      id
    ) as yVault_ZapInOut_General_V1_3ZapinEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_3ZapoutEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_3ZapoutEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_3ZapoutEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_3ZapoutEvent", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_3ZapoutEvent | null {
    return store.get(
      "yVault_ZapInOut_General_V1_3ZapoutEvent",
      id
    ) as yVault_ZapInOut_General_V1_3ZapoutEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_3ZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_3ZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_3ZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_3ZapInCall", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_3ZapInCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_3ZapInCall",
      id
    ) as yVault_ZapInOut_General_V1_3ZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_3ZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_3ZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_3ZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_3ZapOutCall", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_3ZapOutCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_3ZapOutCall",
      id
    ) as yVault_ZapInOut_General_V1_3ZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_3addNewCurveExchangeCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_3addNewCurveExchangeCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_3addNewCurveExchangeCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_3addNewCurveExchangeCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_3addNewCurveExchangeCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_3addNewCurveExchangeCall",
      id
    ) as yVault_ZapInOut_General_V1_3addNewCurveExchangeCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get curvePoolToken(): Bytes {
    let value = this.get("curvePoolToken");
    return value.toBytes();
  }

  set curvePoolToken(value: Bytes) {
    this.set("curvePoolToken", Value.fromBytes(value));
  }

  get curveExchangeAddress(): Bytes {
    let value = this.get("curveExchangeAddress");
    return value.toBytes();
  }

  set curveExchangeAddress(value: Bytes) {
    this.set("curveExchangeAddress", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_3inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_3inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_3inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_3inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_3inCaseTokengetsStuckCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_3inCaseTokengetsStuckCall",
      id
    ) as yVault_ZapInOut_General_V1_3inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_3renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_3renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_3renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_3renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_3renounceOwnershipCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_3renounceOwnershipCall",
      id
    ) as yVault_ZapInOut_General_V1_3renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_3setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_3setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_3setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_3setnewgoodwillCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_3setnewgoodwillCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_3setnewgoodwillCall",
      id
    ) as yVault_ZapInOut_General_V1_3setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_3toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_3toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_3toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_3toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_3toggleContractActiveCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_3toggleContractActiveCall",
      id
    ) as yVault_ZapInOut_General_V1_3toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_3transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_3transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_3transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_3transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_3transferOwnershipCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_3transferOwnershipCall",
      id
    ) as yVault_ZapInOut_General_V1_3transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_3updateCurveZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_3updateCurveZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_3updateCurveZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_3updateCurveZapInCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_3updateCurveZapInCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_3updateCurveZapInCall",
      id
    ) as yVault_ZapInOut_General_V1_3updateCurveZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get CurveZapInGeneralAddress(): Bytes {
    let value = this.get("CurveZapInGeneralAddress");
    return value.toBytes();
  }

  set CurveZapInGeneralAddress(value: Bytes) {
    this.set("CurveZapInGeneralAddress", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_3updateCurveZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_3updateCurveZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_3updateCurveZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_3updateCurveZapOutCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_3updateCurveZapOutCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_3updateCurveZapOutCall",
      id
    ) as yVault_ZapInOut_General_V1_3updateCurveZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get CurveZapOutGeneralAddress(): Bytes {
    let value = this.get("CurveZapOutGeneralAddress");
    return value.toBytes();
  }

  set CurveZapOutGeneralAddress(value: Bytes) {
    this.set("CurveZapOutGeneralAddress", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_3withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_3withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_3withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_3withdrawCall", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_3withdrawCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_3withdrawCall",
      id
    ) as yVault_ZapInOut_General_V1_3withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_4OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_4OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_4OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_4OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_4OwnershipTransferredEvent | null {
    return store.get(
      "yVault_ZapInOut_General_V1_4OwnershipTransferredEvent",
      id
    ) as yVault_ZapInOut_General_V1_4OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_4ZapinEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_4ZapinEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_4ZapinEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_4ZapinEvent", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_4ZapinEvent | null {
    return store.get(
      "yVault_ZapInOut_General_V1_4ZapinEvent",
      id
    ) as yVault_ZapInOut_General_V1_4ZapinEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_4ZapoutEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_4ZapoutEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_4ZapoutEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_4ZapoutEvent", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_4ZapoutEvent | null {
    return store.get(
      "yVault_ZapInOut_General_V1_4ZapoutEvent",
      id
    ) as yVault_ZapInOut_General_V1_4ZapoutEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_4ZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_4ZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_4ZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_4ZapInCall", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_4ZapInCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_4ZapInCall",
      id
    ) as yVault_ZapInOut_General_V1_4ZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_4ZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_4ZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_4ZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_4ZapOutCall", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_4ZapOutCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_4ZapOutCall",
      id
    ) as yVault_ZapInOut_General_V1_4ZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_4addNewCurveExchangeCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_4addNewCurveExchangeCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_4addNewCurveExchangeCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_4addNewCurveExchangeCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_4addNewCurveExchangeCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_4addNewCurveExchangeCall",
      id
    ) as yVault_ZapInOut_General_V1_4addNewCurveExchangeCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get curvePoolToken(): Bytes {
    let value = this.get("curvePoolToken");
    return value.toBytes();
  }

  set curvePoolToken(value: Bytes) {
    this.set("curvePoolToken", Value.fromBytes(value));
  }

  get curveExchangeAddress(): Bytes {
    let value = this.get("curveExchangeAddress");
    return value.toBytes();
  }

  set curveExchangeAddress(value: Bytes) {
    this.set("curveExchangeAddress", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_4inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_4inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_4inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_4inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_4inCaseTokengetsStuckCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_4inCaseTokengetsStuckCall",
      id
    ) as yVault_ZapInOut_General_V1_4inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_4renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_4renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_4renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_4renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_4renounceOwnershipCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_4renounceOwnershipCall",
      id
    ) as yVault_ZapInOut_General_V1_4renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_4setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_4setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_4setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_4setnewgoodwillCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_4setnewgoodwillCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_4setnewgoodwillCall",
      id
    ) as yVault_ZapInOut_General_V1_4setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_4toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_4toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_4toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_4toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_4toggleContractActiveCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_4toggleContractActiveCall",
      id
    ) as yVault_ZapInOut_General_V1_4toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class yVault_ZapInOut_General_V1_4transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_4transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_4transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_4transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_4transferOwnershipCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_4transferOwnershipCall",
      id
    ) as yVault_ZapInOut_General_V1_4transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_4updateCurveZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_4updateCurveZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_4updateCurveZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_4updateCurveZapInCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_4updateCurveZapInCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_4updateCurveZapInCall",
      id
    ) as yVault_ZapInOut_General_V1_4updateCurveZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get CurveZapInGeneralAddress(): Bytes {
    let value = this.get("CurveZapInGeneralAddress");
    return value.toBytes();
  }

  set CurveZapInGeneralAddress(value: Bytes) {
    this.set("CurveZapInGeneralAddress", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_4updateCurveZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_4updateCurveZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_4updateCurveZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVault_ZapInOut_General_V1_4updateCurveZapOutCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVault_ZapInOut_General_V1_4updateCurveZapOutCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_4updateCurveZapOutCall",
      id
    ) as yVault_ZapInOut_General_V1_4updateCurveZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get CurveZapOutGeneralAddress(): Bytes {
    let value = this.get("CurveZapOutGeneralAddress");
    return value.toBytes();
  }

  set CurveZapOutGeneralAddress(value: Bytes) {
    this.set("CurveZapOutGeneralAddress", Value.fromBytes(value));
  }
}

export class yVault_ZapInOut_General_V1_4withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVault_ZapInOut_General_V1_4withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVault_ZapInOut_General_V1_4withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("yVault_ZapInOut_General_V1_4withdrawCall", id.toString(), this);
  }

  static load(id: string): yVault_ZapInOut_General_V1_4withdrawCall | null {
    return store.get(
      "yVault_ZapInOut_General_V1_4withdrawCall",
      id
    ) as yVault_ZapInOut_General_V1_4withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2_6OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2_6OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2_6OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V2_6OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V2_6OwnershipTransferredEvent | null {
    return store.get(
      "Balancer_ZapIn_General_V2_6OwnershipTransferredEvent",
      id
    ) as Balancer_ZapIn_General_V2_6OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_ZapIn_General_V2_6zapEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2_6zapEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2_6zapEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V2_6zapEvent", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V2_6zapEvent | null {
    return store.get(
      "Balancer_ZapIn_General_V2_6zapEvent",
      id
    ) as Balancer_ZapIn_General_V2_6zapEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get zapContract(): Bytes {
    let value = this.get("zapContract");
    return value.toBytes();
  }

  set zapContract(value: Bytes) {
    this.set("zapContract", Value.fromBytes(value));
  }

  get userAddress(): Bytes {
    let value = this.get("userAddress");
    return value.toBytes();
  }

  set userAddress(value: Bytes) {
    this.set("userAddress", Value.fromBytes(value));
  }

  get tokenAddress(): Bytes {
    let value = this.get("tokenAddress");
    return value.toBytes();
  }

  set tokenAddress(value: Bytes) {
    this.set("tokenAddress", Value.fromBytes(value));
  }

  get volume(): BigInt {
    let value = this.get("volume");
    return value.toBigInt();
  }

  set volume(value: BigInt) {
    this.set("volume", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2_6ZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2_6ZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2_6ZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V2_6ZapInCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V2_6ZapInCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2_6ZapInCall",
      id
    ) as Balancer_ZapIn_General_V2_6ZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get tokensBought(): BigInt {
    let value = this.get("tokensBought");
    return value.toBigInt();
  }

  set tokensBought(value: BigInt) {
    this.set("tokensBought", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2_6inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2_6inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2_6inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V2_6inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V2_6inCaseTokengetsStuckCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2_6inCaseTokengetsStuckCall",
      id
    ) as Balancer_ZapIn_General_V2_6inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2_6renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2_6renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2_6renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V2_6renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V2_6renounceOwnershipCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2_6renounceOwnershipCall",
      id
    ) as Balancer_ZapIn_General_V2_6renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2_6setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2_6setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2_6setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V2_6setnewgoodwillCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V2_6setnewgoodwillCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2_6setnewgoodwillCall",
      id
    ) as Balancer_ZapIn_General_V2_6setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2_6setnewzgoodwillAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2_6setnewzgoodwillAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2_6setnewzgoodwillAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V2_6setnewzgoodwillAddressCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V2_6setnewzgoodwillAddressCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2_6setnewzgoodwillAddressCall",
      id
    ) as Balancer_ZapIn_General_V2_6setnewzgoodwillAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2_6toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2_6toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2_6toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V2_6toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V2_6toggleContractActiveCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2_6toggleContractActiveCall",
      id
    ) as Balancer_ZapIn_General_V2_6toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_ZapIn_General_V2_6transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2_6transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2_6transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_ZapIn_General_V2_6transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_ZapIn_General_V2_6transferOwnershipCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2_6transferOwnershipCall",
      id
    ) as Balancer_ZapIn_General_V2_6transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_ZapIn_General_V2_6withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_ZapIn_General_V2_6withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_ZapIn_General_V2_6withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_ZapIn_General_V2_6withdrawCall", id.toString(), this);
  }

  static load(id: string): Balancer_ZapIn_General_V2_6withdrawCall | null {
    return store.get(
      "Balancer_ZapIn_General_V2_6withdrawCall",
      id
    ) as Balancer_ZapIn_General_V2_6withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_UniswapV2_Pipe_V1_4OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_UniswapV2_Pipe_V1_4OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_UniswapV2_Pipe_V1_4OwnershipTransferredEvent | null {
    return store.get(
      "Balancer_UniswapV2_Pipe_V1_4OwnershipTransferredEvent",
      id
    ) as Balancer_UniswapV2_Pipe_V1_4OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_UniswapV2_Pipe_V1_4PipeBalancerUniV2Call extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4PipeBalancerUniV2Call entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4PipeBalancerUniV2Call entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_UniswapV2_Pipe_V1_4PipeBalancerUniV2Call",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_UniswapV2_Pipe_V1_4PipeBalancerUniV2Call | null {
    return store.get(
      "Balancer_UniswapV2_Pipe_V1_4PipeBalancerUniV2Call",
      id
    ) as Balancer_UniswapV2_Pipe_V1_4PipeBalancerUniV2Call | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class Balancer_UniswapV2_Pipe_V1_4PipeUniV2BalancerCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4PipeUniV2BalancerCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4PipeUniV2BalancerCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_UniswapV2_Pipe_V1_4PipeUniV2BalancerCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_UniswapV2_Pipe_V1_4PipeUniV2BalancerCall | null {
    return store.get(
      "Balancer_UniswapV2_Pipe_V1_4PipeUniV2BalancerCall",
      id
    ) as Balancer_UniswapV2_Pipe_V1_4PipeUniV2BalancerCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class Balancer_UniswapV2_Pipe_V1_4inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_UniswapV2_Pipe_V1_4inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_UniswapV2_Pipe_V1_4inCaseTokengetsStuckCall | null {
    return store.get(
      "Balancer_UniswapV2_Pipe_V1_4inCaseTokengetsStuckCall",
      id
    ) as Balancer_UniswapV2_Pipe_V1_4inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_UniswapV2_Pipe_V1_4renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_UniswapV2_Pipe_V1_4renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_UniswapV2_Pipe_V1_4renounceOwnershipCall | null {
    return store.get(
      "Balancer_UniswapV2_Pipe_V1_4renounceOwnershipCall",
      id
    ) as Balancer_UniswapV2_Pipe_V1_4renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_UniswapV2_Pipe_V1_4setBalancerZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4setBalancerZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4setBalancerZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_UniswapV2_Pipe_V1_4setBalancerZapOutCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_UniswapV2_Pipe_V1_4setBalancerZapOutCall | null {
    return store.get(
      "Balancer_UniswapV2_Pipe_V1_4setBalancerZapOutCall",
      id
    ) as Balancer_UniswapV2_Pipe_V1_4setBalancerZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_UniswapV2_Pipe_V1_4setUniswapV2ZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4setUniswapV2ZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4setUniswapV2ZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_UniswapV2_Pipe_V1_4setUniswapV2ZapInCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_UniswapV2_Pipe_V1_4setUniswapV2ZapInCall | null {
    return store.get(
      "Balancer_UniswapV2_Pipe_V1_4setUniswapV2ZapInCall",
      id
    ) as Balancer_UniswapV2_Pipe_V1_4setUniswapV2ZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_UniswapV2_Pipe_V1_4setUniswapV2ZapOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4setUniswapV2ZapOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4setUniswapV2ZapOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_UniswapV2_Pipe_V1_4setUniswapV2ZapOutCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_UniswapV2_Pipe_V1_4setUniswapV2ZapOutCall | null {
    return store.get(
      "Balancer_UniswapV2_Pipe_V1_4setUniswapV2ZapOutCall",
      id
    ) as Balancer_UniswapV2_Pipe_V1_4setUniswapV2ZapOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_UniswapV2_Pipe_V1_4setbalancerZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4setbalancerZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4setbalancerZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_UniswapV2_Pipe_V1_4setbalancerZapInCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_UniswapV2_Pipe_V1_4setbalancerZapInCall | null {
    return store.get(
      "Balancer_UniswapV2_Pipe_V1_4setbalancerZapInCall",
      id
    ) as Balancer_UniswapV2_Pipe_V1_4setbalancerZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_UniswapV2_Pipe_V1_4toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_UniswapV2_Pipe_V1_4toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_UniswapV2_Pipe_V1_4toggleContractActiveCall | null {
    return store.get(
      "Balancer_UniswapV2_Pipe_V1_4toggleContractActiveCall",
      id
    ) as Balancer_UniswapV2_Pipe_V1_4toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Balancer_UniswapV2_Pipe_V1_4transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Balancer_UniswapV2_Pipe_V1_4transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Balancer_UniswapV2_Pipe_V1_4transferOwnershipCall | null {
    return store.get(
      "Balancer_UniswapV2_Pipe_V1_4transferOwnershipCall",
      id
    ) as Balancer_UniswapV2_Pipe_V1_4transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Balancer_UniswapV2_Pipe_V1_4withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Balancer_UniswapV2_Pipe_V1_4withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Balancer_UniswapV2_Pipe_V1_4withdrawCall", id.toString(), this);
  }

  static load(id: string): Balancer_UniswapV2_Pipe_V1_4withdrawCall | null {
    return store.get(
      "Balancer_UniswapV2_Pipe_V1_4withdrawCall",
      id
    ) as Balancer_UniswapV2_Pipe_V1_4withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Zapper_Swap_General_V1_3OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Zapper_Swap_General_V1_3OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Zapper_Swap_General_V1_3OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Zapper_Swap_General_V1_3OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Zapper_Swap_General_V1_3OwnershipTransferredEvent | null {
    return store.get(
      "Zapper_Swap_General_V1_3OwnershipTransferredEvent",
      id
    ) as Zapper_Swap_General_V1_3OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Zapper_Swap_General_V1_3MultiExchangeSwapCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Zapper_Swap_General_V1_3MultiExchangeSwapCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Zapper_Swap_General_V1_3MultiExchangeSwapCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Zapper_Swap_General_V1_3MultiExchangeSwapCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Zapper_Swap_General_V1_3MultiExchangeSwapCall | null {
    return store.get(
      "Zapper_Swap_General_V1_3MultiExchangeSwapCall",
      id
    ) as Zapper_Swap_General_V1_3MultiExchangeSwapCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get toWhomToIssue(): Bytes {
    let value = this.get("toWhomToIssue");
    return value.toBytes();
  }

  set toWhomToIssue(value: Bytes) {
    this.set("toWhomToIssue", Value.fromBytes(value));
  }

  get path(): Array<Address> {
    let value = this.get("path");
    return value.toAddressArray();
  }

  set path(value: Array<Address>) {
    this.set("path", Value.fromAddressArray(value));
  }

  get amountIn(): BigInt {
    let value = this.get("amountIn");
    return value.toBigInt();
  }

  set amountIn(value: BigInt) {
    this.set("amountIn", Value.fromBigInt(value));
  }

  get minTokenOut(): BigInt {
    let value = this.get("minTokenOut");
    return value.toBigInt();
  }

  set minTokenOut(value: BigInt) {
    this.set("minTokenOut", Value.fromBigInt(value));
  }

  get starts(): Array<i32> {
    let value = this.get("starts");
    return value.toI32Array();
  }

  set starts(value: Array<i32>) {
    this.set("starts", Value.fromI32Array(value));
  }

  get withPool(): Array<i32> {
    let value = this.get("withPool");
    return value.toI32Array();
  }

  set withPool(value: Array<i32>) {
    this.set("withPool", Value.fromI32Array(value));
  }

  get poolData(): Array<Address> {
    let value = this.get("poolData");
    return value.toAddressArray();
  }

  set poolData(value: Array<Address>) {
    this.set("poolData", Value.fromAddressArray(value));
  }

  get tokensBought(): BigInt {
    let value = this.get("tokensBought");
    return value.toBigInt();
  }

  set tokensBought(value: BigInt) {
    this.set("tokensBought", Value.fromBigInt(value));
  }
}

export class Zapper_Swap_General_V1_3addATokenCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Zapper_Swap_General_V1_3addATokenCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Zapper_Swap_General_V1_3addATokenCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Zapper_Swap_General_V1_3addATokenCall", id.toString(), this);
  }

  static load(id: string): Zapper_Swap_General_V1_3addATokenCall | null {
    return store.get(
      "Zapper_Swap_General_V1_3addATokenCall",
      id
    ) as Zapper_Swap_General_V1_3addATokenCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Zapper_Swap_General_V1_3addCTokenCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Zapper_Swap_General_V1_3addCTokenCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Zapper_Swap_General_V1_3addCTokenCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Zapper_Swap_General_V1_3addCTokenCall", id.toString(), this);
  }

  static load(id: string): Zapper_Swap_General_V1_3addCTokenCall | null {
    return store.get(
      "Zapper_Swap_General_V1_3addCTokenCall",
      id
    ) as Zapper_Swap_General_V1_3addCTokenCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Zapper_Swap_General_V1_3addYTokenCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Zapper_Swap_General_V1_3addYTokenCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Zapper_Swap_General_V1_3addYTokenCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Zapper_Swap_General_V1_3addYTokenCall", id.toString(), this);
  }

  static load(id: string): Zapper_Swap_General_V1_3addYTokenCall | null {
    return store.get(
      "Zapper_Swap_General_V1_3addYTokenCall",
      id
    ) as Zapper_Swap_General_V1_3addYTokenCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Zapper_Swap_General_V1_3inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Zapper_Swap_General_V1_3inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Zapper_Swap_General_V1_3inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Zapper_Swap_General_V1_3inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Zapper_Swap_General_V1_3inCaseTokengetsStuckCall | null {
    return store.get(
      "Zapper_Swap_General_V1_3inCaseTokengetsStuckCall",
      id
    ) as Zapper_Swap_General_V1_3inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Zapper_Swap_General_V1_3renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Zapper_Swap_General_V1_3renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Zapper_Swap_General_V1_3renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Zapper_Swap_General_V1_3renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Zapper_Swap_General_V1_3renounceOwnershipCall | null {
    return store.get(
      "Zapper_Swap_General_V1_3renounceOwnershipCall",
      id
    ) as Zapper_Swap_General_V1_3renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Zapper_Swap_General_V1_3toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Zapper_Swap_General_V1_3toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Zapper_Swap_General_V1_3toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Zapper_Swap_General_V1_3toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Zapper_Swap_General_V1_3toggleContractActiveCall | null {
    return store.get(
      "Zapper_Swap_General_V1_3toggleContractActiveCall",
      id
    ) as Zapper_Swap_General_V1_3toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Zapper_Swap_General_V1_3transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Zapper_Swap_General_V1_3transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Zapper_Swap_General_V1_3transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Zapper_Swap_General_V1_3transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Zapper_Swap_General_V1_3transferOwnershipCall | null {
    return store.get(
      "Zapper_Swap_General_V1_3transferOwnershipCall",
      id
    ) as Zapper_Swap_General_V1_3transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Zapper_Swap_General_V1_3unwrapCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Zapper_Swap_General_V1_3unwrapCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Zapper_Swap_General_V1_3unwrapCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Zapper_Swap_General_V1_3unwrapCall", id.toString(), this);
  }

  static load(id: string): Zapper_Swap_General_V1_3unwrapCall | null {
    return store.get(
      "Zapper_Swap_General_V1_3unwrapCall",
      id
    ) as Zapper_Swap_General_V1_3unwrapCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get tokens2Trade(): BigInt {
    let value = this.get("tokens2Trade");
    return value.toBigInt();
  }

  set tokens2Trade(value: BigInt) {
    this.set("tokens2Trade", Value.fromBigInt(value));
  }

  get minTokens(): BigInt {
    let value = this.get("minTokens");
    return value.toBigInt();
  }

  set minTokens(value: BigInt) {
    this.set("minTokens", Value.fromBigInt(value));
  }

  get tokensUnwrapped(): BigInt {
    let value = this.get("tokensUnwrapped");
    return value.toBigInt();
  }

  set tokensUnwrapped(value: BigInt) {
    this.set("tokensUnwrapped", Value.fromBigInt(value));
  }

  get toToken(): Bytes {
    let value = this.get("toToken");
    return value.toBytes();
  }

  set toToken(value: Bytes) {
    this.set("toToken", Value.fromBytes(value));
  }
}

export class Zapper_Swap_General_V1_3unwrapWethCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Zapper_Swap_General_V1_3unwrapWethCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Zapper_Swap_General_V1_3unwrapWethCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Zapper_Swap_General_V1_3unwrapWethCall", id.toString(), this);
  }

  static load(id: string): Zapper_Swap_General_V1_3unwrapWethCall | null {
    return store.get(
      "Zapper_Swap_General_V1_3unwrapWethCall",
      id
    ) as Zapper_Swap_General_V1_3unwrapWethCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get tokens2Trade(): BigInt {
    let value = this.get("tokens2Trade");
    return value.toBigInt();
  }

  set tokens2Trade(value: BigInt) {
    this.set("tokens2Trade", Value.fromBigInt(value));
  }

  get minTokens(): BigInt {
    let value = this.get("minTokens");
    return value.toBigInt();
  }

  set minTokens(value: BigInt) {
    this.set("minTokens", Value.fromBigInt(value));
  }

  get tokensUnwrapped(): BigInt {
    let value = this.get("tokensUnwrapped");
    return value.toBigInt();
  }

  set tokensUnwrapped(value: BigInt) {
    this.set("tokensUnwrapped", Value.fromBigInt(value));
  }

  get toToken(): Bytes {
    let value = this.get("toToken");
    return value.toBytes();
  }

  set toToken(value: Bytes) {
    this.set("toToken", Value.fromBytes(value));
  }
}

export class Zapper_Swap_General_V1_3wrapCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Zapper_Swap_General_V1_3wrapCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Zapper_Swap_General_V1_3wrapCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Zapper_Swap_General_V1_3wrapCall", id.toString(), this);
  }

  static load(id: string): Zapper_Swap_General_V1_3wrapCall | null {
    return store.get(
      "Zapper_Swap_General_V1_3wrapCall",
      id
    ) as Zapper_Swap_General_V1_3wrapCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get tokens2Trade(): BigInt {
    let value = this.get("tokens2Trade");
    return value.toBigInt();
  }

  set tokens2Trade(value: BigInt) {
    this.set("tokens2Trade", Value.fromBigInt(value));
  }

  get minTokens(): BigInt {
    let value = this.get("minTokens");
    return value.toBigInt();
  }

  set minTokens(value: BigInt) {
    this.set("minTokens", Value.fromBigInt(value));
  }

  get tokensWrapped(): BigInt {
    let value = this.get("tokensWrapped");
    return value.toBigInt();
  }

  set tokensWrapped(value: BigInt) {
    this.set("tokensWrapped", Value.fromBigInt(value));
  }
}

export class UniswapV2_ZapIn_General_V2_4_1OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapIn_General_V2_4_1OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapIn_General_V2_4_1OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UniswapV2_ZapIn_General_V2_4_1OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): UniswapV2_ZapIn_General_V2_4_1OwnershipTransferredEvent | null {
    return store.get(
      "UniswapV2_ZapIn_General_V2_4_1OwnershipTransferredEvent",
      id
    ) as UniswapV2_ZapIn_General_V2_4_1OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class UniswapV2_ZapIn_General_V2_4_1ZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapIn_General_V2_4_1ZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapIn_General_V2_4_1ZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UniswapV2_ZapIn_General_V2_4_1ZapInCall", id.toString(), this);
  }

  static load(id: string): UniswapV2_ZapIn_General_V2_4_1ZapInCall | null {
    return store.get(
      "UniswapV2_ZapIn_General_V2_4_1ZapInCall",
      id
    ) as UniswapV2_ZapIn_General_V2_4_1ZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class UniswapV2_ZapIn_General_V2_4_1inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapIn_General_V2_4_1inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapIn_General_V2_4_1inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UniswapV2_ZapIn_General_V2_4_1inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): UniswapV2_ZapIn_General_V2_4_1inCaseTokengetsStuckCall | null {
    return store.get(
      "UniswapV2_ZapIn_General_V2_4_1inCaseTokengetsStuckCall",
      id
    ) as UniswapV2_ZapIn_General_V2_4_1inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV2_ZapIn_General_V2_4_1renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapIn_General_V2_4_1renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapIn_General_V2_4_1renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UniswapV2_ZapIn_General_V2_4_1renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): UniswapV2_ZapIn_General_V2_4_1renounceOwnershipCall | null {
    return store.get(
      "UniswapV2_ZapIn_General_V2_4_1renounceOwnershipCall",
      id
    ) as UniswapV2_ZapIn_General_V2_4_1renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV2_ZapIn_General_V2_4_1setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapIn_General_V2_4_1setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapIn_General_V2_4_1setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UniswapV2_ZapIn_General_V2_4_1setnewgoodwillCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): UniswapV2_ZapIn_General_V2_4_1setnewgoodwillCall | null {
    return store.get(
      "UniswapV2_ZapIn_General_V2_4_1setnewgoodwillCall",
      id
    ) as UniswapV2_ZapIn_General_V2_4_1setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV2_ZapIn_General_V2_4_1toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapIn_General_V2_4_1toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapIn_General_V2_4_1toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UniswapV2_ZapIn_General_V2_4_1toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): UniswapV2_ZapIn_General_V2_4_1toggleContractActiveCall | null {
    return store.get(
      "UniswapV2_ZapIn_General_V2_4_1toggleContractActiveCall",
      id
    ) as UniswapV2_ZapIn_General_V2_4_1toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class UniswapV2_ZapIn_General_V2_4_1transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapIn_General_V2_4_1transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapIn_General_V2_4_1transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UniswapV2_ZapIn_General_V2_4_1transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): UniswapV2_ZapIn_General_V2_4_1transferOwnershipCall | null {
    return store.get(
      "UniswapV2_ZapIn_General_V2_4_1transferOwnershipCall",
      id
    ) as UniswapV2_ZapIn_General_V2_4_1transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class UniswapV2_ZapIn_General_V2_4_1withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save UniswapV2_ZapIn_General_V2_4_1withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UniswapV2_ZapIn_General_V2_4_1withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "UniswapV2_ZapIn_General_V2_4_1withdrawCall",
      id.toString(),
      this
    );
  }

  static load(id: string): UniswapV2_ZapIn_General_V2_4_1withdrawCall | null {
    return store.get(
      "UniswapV2_ZapIn_General_V2_4_1withdrawCall",
      id
    ) as UniswapV2_ZapIn_General_V2_4_1withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_ZapIn_General_V1_9OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_ZapIn_General_V1_9OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_ZapIn_General_V1_9OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_ZapIn_General_V1_9OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Curve_ZapIn_General_V1_9OwnershipTransferredEvent | null {
    return store.get(
      "Curve_ZapIn_General_V1_9OwnershipTransferredEvent",
      id
    ) as Curve_ZapIn_General_V1_9OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Curve_ZapIn_General_V1_9ZapInCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_ZapIn_General_V1_9ZapInCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_ZapIn_General_V1_9ZapInCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_ZapIn_General_V1_9ZapInCall", id.toString(), this);
  }

  static load(id: string): Curve_ZapIn_General_V1_9ZapInCall | null {
    return store.get(
      "Curve_ZapIn_General_V1_9ZapInCall",
      id
    ) as Curve_ZapIn_General_V1_9ZapInCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get toWhomToIssue(): Bytes {
    let value = this.get("toWhomToIssue");
    return value.toBytes();
  }

  set toWhomToIssue(value: Bytes) {
    this.set("toWhomToIssue", Value.fromBytes(value));
  }

  get fromToken(): Bytes {
    let value = this.get("fromToken");
    return value.toBytes();
  }

  set fromToken(value: Bytes) {
    this.set("fromToken", Value.fromBytes(value));
  }

  get swapAddress(): Bytes {
    let value = this.get("swapAddress");
    return value.toBytes();
  }

  set swapAddress(value: Bytes) {
    this.set("swapAddress", Value.fromBytes(value));
  }

  get incomingTokenQty(): BigInt {
    let value = this.get("incomingTokenQty");
    return value.toBigInt();
  }

  set incomingTokenQty(value: BigInt) {
    this.set("incomingTokenQty", Value.fromBigInt(value));
  }

  get minPoolTokens(): BigInt {
    let value = this.get("minPoolTokens");
    return value.toBigInt();
  }

  set minPoolTokens(value: BigInt) {
    this.set("minPoolTokens", Value.fromBigInt(value));
  }

  get crvTokensBought(): BigInt {
    let value = this.get("crvTokensBought");
    return value.toBigInt();
  }

  set crvTokensBought(value: BigInt) {
    this.set("crvTokensBought", Value.fromBigInt(value));
  }
}

export class Curve_ZapIn_General_V1_9addPoolCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_ZapIn_General_V1_9addPoolCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_ZapIn_General_V1_9addPoolCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_ZapIn_General_V1_9addPoolCall", id.toString(), this);
  }

  static load(id: string): Curve_ZapIn_General_V1_9addPoolCall | null {
    return store.get(
      "Curve_ZapIn_General_V1_9addPoolCall",
      id
    ) as Curve_ZapIn_General_V1_9addPoolCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get swapAddress(): Bytes {
    let value = this.get("swapAddress");
    return value.toBytes();
  }

  set swapAddress(value: Bytes) {
    this.set("swapAddress", Value.fromBytes(value));
  }

  get tokenAddress(): Bytes {
    let value = this.get("tokenAddress");
    return value.toBytes();
  }

  set tokenAddress(value: Bytes) {
    this.set("tokenAddress", Value.fromBytes(value));
  }

  get poolTokens(): Array<Address> {
    let value = this.get("poolTokens");
    return value.toAddressArray();
  }

  set poolTokens(value: Array<Address>) {
    this.set("poolTokens", Value.fromAddressArray(value));
  }

  get isMetaPool(): boolean {
    let value = this.get("isMetaPool");
    return value.toBoolean();
  }

  set isMetaPool(value: boolean) {
    this.set("isMetaPool", Value.fromBoolean(value));
  }
}

export class Curve_ZapIn_General_V1_9inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_ZapIn_General_V1_9inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_ZapIn_General_V1_9inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_ZapIn_General_V1_9inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Curve_ZapIn_General_V1_9inCaseTokengetsStuckCall | null {
    return store.get(
      "Curve_ZapIn_General_V1_9inCaseTokengetsStuckCall",
      id
    ) as Curve_ZapIn_General_V1_9inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_ZapIn_General_V1_9renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_ZapIn_General_V1_9renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_ZapIn_General_V1_9renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_ZapIn_General_V1_9renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Curve_ZapIn_General_V1_9renounceOwnershipCall | null {
    return store.get(
      "Curve_ZapIn_General_V1_9renounceOwnershipCall",
      id
    ) as Curve_ZapIn_General_V1_9renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_ZapIn_General_V1_9setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_ZapIn_General_V1_9setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_ZapIn_General_V1_9setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_ZapIn_General_V1_9setnewgoodwillCall",
      id.toString(),
      this
    );
  }

  static load(id: string): Curve_ZapIn_General_V1_9setnewgoodwillCall | null {
    return store.get(
      "Curve_ZapIn_General_V1_9setnewgoodwillCall",
      id
    ) as Curve_ZapIn_General_V1_9setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_ZapIn_General_V1_9setnewzgoodwillAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_ZapIn_General_V1_9setnewzgoodwillAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_ZapIn_General_V1_9setnewzgoodwillAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_ZapIn_General_V1_9setnewzgoodwillAddressCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Curve_ZapIn_General_V1_9setnewzgoodwillAddressCall | null {
    return store.get(
      "Curve_ZapIn_General_V1_9setnewzgoodwillAddressCall",
      id
    ) as Curve_ZapIn_General_V1_9setnewzgoodwillAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_ZapIn_General_V1_9toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_ZapIn_General_V1_9toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_ZapIn_General_V1_9toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_ZapIn_General_V1_9toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Curve_ZapIn_General_V1_9toggleContractActiveCall | null {
    return store.get(
      "Curve_ZapIn_General_V1_9toggleContractActiveCall",
      id
    ) as Curve_ZapIn_General_V1_9toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Curve_ZapIn_General_V1_9transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_ZapIn_General_V1_9transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_ZapIn_General_V1_9transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_ZapIn_General_V1_9transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Curve_ZapIn_General_V1_9transferOwnershipCall | null {
    return store.get(
      "Curve_ZapIn_General_V1_9transferOwnershipCall",
      id
    ) as Curve_ZapIn_General_V1_9transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Curve_ZapIn_General_V1_9updateIntermediateStableCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_ZapIn_General_V1_9updateIntermediateStableCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_ZapIn_General_V1_9updateIntermediateStableCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Curve_ZapIn_General_V1_9updateIntermediateStableCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Curve_ZapIn_General_V1_9updateIntermediateStableCall | null {
    return store.get(
      "Curve_ZapIn_General_V1_9updateIntermediateStableCall",
      id
    ) as Curve_ZapIn_General_V1_9updateIntermediateStableCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newIntermediate(): Bytes {
    let value = this.get("newIntermediate");
    return value.toBytes();
  }

  set newIntermediate(value: Bytes) {
    this.set("newIntermediate", Value.fromBytes(value));
  }
}

export class Curve_ZapIn_General_V1_9updatePoolCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_ZapIn_General_V1_9updatePoolCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_ZapIn_General_V1_9updatePoolCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_ZapIn_General_V1_9updatePoolCall", id.toString(), this);
  }

  static load(id: string): Curve_ZapIn_General_V1_9updatePoolCall | null {
    return store.get(
      "Curve_ZapIn_General_V1_9updatePoolCall",
      id
    ) as Curve_ZapIn_General_V1_9updatePoolCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get swapAddress(): Bytes {
    let value = this.get("swapAddress");
    return value.toBytes();
  }

  set swapAddress(value: Bytes) {
    this.set("swapAddress", Value.fromBytes(value));
  }

  get tokenAddress(): Bytes {
    let value = this.get("tokenAddress");
    return value.toBytes();
  }

  set tokenAddress(value: Bytes) {
    this.set("tokenAddress", Value.fromBytes(value));
  }

  get poolTokens(): Array<Address> {
    let value = this.get("poolTokens");
    return value.toAddressArray();
  }

  set poolTokens(value: Array<Address>) {
    this.set("poolTokens", Value.fromAddressArray(value));
  }

  get isMetaPool(): boolean {
    let value = this.get("isMetaPool");
    return value.toBoolean();
  }

  set isMetaPool(value: boolean) {
    this.set("isMetaPool", Value.fromBoolean(value));
  }
}

export class Curve_ZapIn_General_V1_9withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Curve_ZapIn_General_V1_9withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Curve_ZapIn_General_V1_9withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Curve_ZapIn_General_V1_9withdrawCall", id.toString(), this);
  }

  static load(id: string): Curve_ZapIn_General_V1_9withdrawCall | null {
    return store.get(
      "Curve_ZapIn_General_V1_9withdrawCall",
      id
    ) as Curve_ZapIn_General_V1_9withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Unipool_Bridge_Zap_V1OwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Unipool_Bridge_Zap_V1OwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Unipool_Bridge_Zap_V1OwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Unipool_Bridge_Zap_V1OwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Unipool_Bridge_Zap_V1OwnershipTransferredEvent | null {
    return store.get(
      "Unipool_Bridge_Zap_V1OwnershipTransferredEvent",
      id
    ) as Unipool_Bridge_Zap_V1OwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Unipool_Bridge_Zap_V1ZapBridgeCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Unipool_Bridge_Zap_V1ZapBridgeCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Unipool_Bridge_Zap_V1ZapBridgeCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Unipool_Bridge_Zap_V1ZapBridgeCall", id.toString(), this);
  }

  static load(id: string): Unipool_Bridge_Zap_V1ZapBridgeCall | null {
    return store.get(
      "Unipool_Bridge_Zap_V1ZapBridgeCall",
      id
    ) as Unipool_Bridge_Zap_V1ZapBridgeCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): boolean {
    let value = this.get("value0");
    return value.toBoolean();
  }

  set value0(value: boolean) {
    this.set("value0", Value.fromBoolean(value));
  }
}

export class Unipool_Bridge_Zap_V1destructCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Unipool_Bridge_Zap_V1destructCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Unipool_Bridge_Zap_V1destructCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Unipool_Bridge_Zap_V1destructCall", id.toString(), this);
  }

  static load(id: string): Unipool_Bridge_Zap_V1destructCall | null {
    return store.get(
      "Unipool_Bridge_Zap_V1destructCall",
      id
    ) as Unipool_Bridge_Zap_V1destructCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Unipool_Bridge_Zap_V1inCaseTokengetsStuckCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Unipool_Bridge_Zap_V1inCaseTokengetsStuckCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Unipool_Bridge_Zap_V1inCaseTokengetsStuckCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Unipool_Bridge_Zap_V1inCaseTokengetsStuckCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Unipool_Bridge_Zap_V1inCaseTokengetsStuckCall | null {
    return store.get(
      "Unipool_Bridge_Zap_V1inCaseTokengetsStuckCall",
      id
    ) as Unipool_Bridge_Zap_V1inCaseTokengetsStuckCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Unipool_Bridge_Zap_V1renounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Unipool_Bridge_Zap_V1renounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Unipool_Bridge_Zap_V1renounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Unipool_Bridge_Zap_V1renounceOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(id: string): Unipool_Bridge_Zap_V1renounceOwnershipCall | null {
    return store.get(
      "Unipool_Bridge_Zap_V1renounceOwnershipCall",
      id
    ) as Unipool_Bridge_Zap_V1renounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Unipool_Bridge_Zap_V1setnewUniSwapFactoryAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Unipool_Bridge_Zap_V1setnewUniSwapFactoryAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Unipool_Bridge_Zap_V1setnewUniSwapFactoryAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Unipool_Bridge_Zap_V1setnewUniSwapFactoryAddressCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Unipool_Bridge_Zap_V1setnewUniSwapFactoryAddressCall | null {
    return store.get(
      "Unipool_Bridge_Zap_V1setnewUniSwapFactoryAddressCall",
      id
    ) as Unipool_Bridge_Zap_V1setnewUniSwapFactoryAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Unipool_Bridge_Zap_V1setnewdzgoodwillAddressCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Unipool_Bridge_Zap_V1setnewdzgoodwillAddressCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Unipool_Bridge_Zap_V1setnewdzgoodwillAddressCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Unipool_Bridge_Zap_V1setnewdzgoodwillAddressCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Unipool_Bridge_Zap_V1setnewdzgoodwillAddressCall | null {
    return store.get(
      "Unipool_Bridge_Zap_V1setnewdzgoodwillAddressCall",
      id
    ) as Unipool_Bridge_Zap_V1setnewdzgoodwillAddressCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Unipool_Bridge_Zap_V1setnewgoodwillCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Unipool_Bridge_Zap_V1setnewgoodwillCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Unipool_Bridge_Zap_V1setnewgoodwillCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Unipool_Bridge_Zap_V1setnewgoodwillCall", id.toString(), this);
  }

  static load(id: string): Unipool_Bridge_Zap_V1setnewgoodwillCall | null {
    return store.get(
      "Unipool_Bridge_Zap_V1setnewgoodwillCall",
      id
    ) as Unipool_Bridge_Zap_V1setnewgoodwillCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Unipool_Bridge_Zap_V1toggleContractActiveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Unipool_Bridge_Zap_V1toggleContractActiveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Unipool_Bridge_Zap_V1toggleContractActiveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Unipool_Bridge_Zap_V1toggleContractActiveCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): Unipool_Bridge_Zap_V1toggleContractActiveCall | null {
    return store.get(
      "Unipool_Bridge_Zap_V1toggleContractActiveCall",
      id
    ) as Unipool_Bridge_Zap_V1toggleContractActiveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Unipool_Bridge_Zap_V1transferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Unipool_Bridge_Zap_V1transferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Unipool_Bridge_Zap_V1transferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "Unipool_Bridge_Zap_V1transferOwnershipCall",
      id.toString(),
      this
    );
  }

  static load(id: string): Unipool_Bridge_Zap_V1transferOwnershipCall | null {
    return store.get(
      "Unipool_Bridge_Zap_V1transferOwnershipCall",
      id
    ) as Unipool_Bridge_Zap_V1transferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Unipool_Bridge_Zap_V1withdrawCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save Unipool_Bridge_Zap_V1withdrawCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Unipool_Bridge_Zap_V1withdrawCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Unipool_Bridge_Zap_V1withdrawCall", id.toString(), this);
  }

  static load(id: string): Unipool_Bridge_Zap_V1withdrawCall | null {
    return store.get(
      "Unipool_Bridge_Zap_V1withdrawCall",
      id
    ) as Unipool_Bridge_Zap_V1withdrawCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class AdminUpgradeabilityProxyApprovalEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save AdminUpgradeabilityProxyApprovalEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AdminUpgradeabilityProxyApprovalEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("AdminUpgradeabilityProxyApprovalEvent", id.toString(), this);
  }

  static load(id: string): AdminUpgradeabilityProxyApprovalEvent | null {
    return store.get(
      "AdminUpgradeabilityProxyApprovalEvent",
      id
    ) as AdminUpgradeabilityProxyApprovalEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    return value.toBytes();
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class AdminUpgradeabilityProxyMinterAddedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save AdminUpgradeabilityProxyMinterAddedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AdminUpgradeabilityProxyMinterAddedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("AdminUpgradeabilityProxyMinterAddedEvent", id.toString(), this);
  }

  static load(id: string): AdminUpgradeabilityProxyMinterAddedEvent | null {
    return store.get(
      "AdminUpgradeabilityProxyMinterAddedEvent",
      id
    ) as AdminUpgradeabilityProxyMinterAddedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }
}

export class AdminUpgradeabilityProxyMinterRemovedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save AdminUpgradeabilityProxyMinterRemovedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AdminUpgradeabilityProxyMinterRemovedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "AdminUpgradeabilityProxyMinterRemovedEvent",
      id.toString(),
      this
    );
  }

  static load(id: string): AdminUpgradeabilityProxyMinterRemovedEvent | null {
    return store.get(
      "AdminUpgradeabilityProxyMinterRemovedEvent",
      id
    ) as AdminUpgradeabilityProxyMinterRemovedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }
}

export class AdminUpgradeabilityProxyTransferEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save AdminUpgradeabilityProxyTransferEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AdminUpgradeabilityProxyTransferEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("AdminUpgradeabilityProxyTransferEvent", id.toString(), this);
  }

  static load(id: string): AdminUpgradeabilityProxyTransferEvent | null {
    return store.get(
      "AdminUpgradeabilityProxyTransferEvent",
      id
    ) as AdminUpgradeabilityProxyTransferEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class AdminUpgradeabilityProxyaddMinterCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save AdminUpgradeabilityProxyaddMinterCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AdminUpgradeabilityProxyaddMinterCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("AdminUpgradeabilityProxyaddMinterCall", id.toString(), this);
  }

  static load(id: string): AdminUpgradeabilityProxyaddMinterCall | null {
    return store.get(
      "AdminUpgradeabilityProxyaddMinterCall",
      id
    ) as AdminUpgradeabilityProxyaddMinterCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }
}

export class AdminUpgradeabilityProxyapproveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save AdminUpgradeabilityProxyapproveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AdminUpgradeabilityProxyapproveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("AdminUpgradeabilityProxyapproveCall", id.toString(), this);
  }

  static load(id: string): AdminUpgradeabilityProxyapproveCall | null {
    return store.get(
      "AdminUpgradeabilityProxyapproveCall",
      id
    ) as AdminUpgradeabilityProxyapproveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    return value.toBytes();
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get value0(): boolean {
    let value = this.get("value0");
    return value.toBoolean();
  }

  set value0(value: boolean) {
    this.set("value0", Value.fromBoolean(value));
  }
}

export class AdminUpgradeabilityProxydecreaseAllowanceCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save AdminUpgradeabilityProxydecreaseAllowanceCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AdminUpgradeabilityProxydecreaseAllowanceCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "AdminUpgradeabilityProxydecreaseAllowanceCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): AdminUpgradeabilityProxydecreaseAllowanceCall | null {
    return store.get(
      "AdminUpgradeabilityProxydecreaseAllowanceCall",
      id
    ) as AdminUpgradeabilityProxydecreaseAllowanceCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    return value.toBytes();
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get subtractedValue(): BigInt {
    let value = this.get("subtractedValue");
    return value.toBigInt();
  }

  set subtractedValue(value: BigInt) {
    this.set("subtractedValue", Value.fromBigInt(value));
  }

  get value0(): boolean {
    let value = this.get("value0");
    return value.toBoolean();
  }

  set value0(value: boolean) {
    this.set("value0", Value.fromBoolean(value));
  }
}

export class AdminUpgradeabilityProxyincreaseAllowanceCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save AdminUpgradeabilityProxyincreaseAllowanceCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AdminUpgradeabilityProxyincreaseAllowanceCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "AdminUpgradeabilityProxyincreaseAllowanceCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): AdminUpgradeabilityProxyincreaseAllowanceCall | null {
    return store.get(
      "AdminUpgradeabilityProxyincreaseAllowanceCall",
      id
    ) as AdminUpgradeabilityProxyincreaseAllowanceCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    return value.toBytes();
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get addedValue(): BigInt {
    let value = this.get("addedValue");
    return value.toBigInt();
  }

  set addedValue(value: BigInt) {
    this.set("addedValue", Value.fromBigInt(value));
  }

  get value0(): boolean {
    let value = this.get("value0");
    return value.toBoolean();
  }

  set value0(value: boolean) {
    this.set("value0", Value.fromBoolean(value));
  }
}

export class AdminUpgradeabilityProxyinitializeCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save AdminUpgradeabilityProxyinitializeCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AdminUpgradeabilityProxyinitializeCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("AdminUpgradeabilityProxyinitializeCall", id.toString(), this);
  }

  static load(id: string): AdminUpgradeabilityProxyinitializeCall | null {
    return store.get(
      "AdminUpgradeabilityProxyinitializeCall",
      id
    ) as AdminUpgradeabilityProxyinitializeCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get name(): string {
    let value = this.get("name");
    return value.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    return value.toString();
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get decimals(): i32 {
    let value = this.get("decimals");
    return value.toI32();
  }

  set decimals(value: i32) {
    this.set("decimals", Value.fromI32(value));
  }
}

export class AdminUpgradeabilityProxyinitialize1Call extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save AdminUpgradeabilityProxyinitialize1Call entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AdminUpgradeabilityProxyinitialize1Call entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("AdminUpgradeabilityProxyinitialize1Call", id.toString(), this);
  }

  static load(id: string): AdminUpgradeabilityProxyinitialize1Call | null {
    return store.get(
      "AdminUpgradeabilityProxyinitialize1Call",
      id
    ) as AdminUpgradeabilityProxyinitialize1Call | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class AdminUpgradeabilityProxyinitialize2Call extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save AdminUpgradeabilityProxyinitialize2Call entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AdminUpgradeabilityProxyinitialize2Call entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("AdminUpgradeabilityProxyinitialize2Call", id.toString(), this);
  }

  static load(id: string): AdminUpgradeabilityProxyinitialize2Call | null {
    return store.get(
      "AdminUpgradeabilityProxyinitialize2Call",
      id
    ) as AdminUpgradeabilityProxyinitialize2Call | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }
}

export class AdminUpgradeabilityProxymintCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save AdminUpgradeabilityProxymintCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AdminUpgradeabilityProxymintCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("AdminUpgradeabilityProxymintCall", id.toString(), this);
  }

  static load(id: string): AdminUpgradeabilityProxymintCall | null {
    return store.get(
      "AdminUpgradeabilityProxymintCall",
      id
    ) as AdminUpgradeabilityProxymintCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get value0(): boolean {
    let value = this.get("value0");
    return value.toBoolean();
  }

  set value0(value: boolean) {
    this.set("value0", Value.fromBoolean(value));
  }
}

export class AdminUpgradeabilityProxyrenounceMinterCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save AdminUpgradeabilityProxyrenounceMinterCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AdminUpgradeabilityProxyrenounceMinterCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "AdminUpgradeabilityProxyrenounceMinterCall",
      id.toString(),
      this
    );
  }

  static load(id: string): AdminUpgradeabilityProxyrenounceMinterCall | null {
    return store.get(
      "AdminUpgradeabilityProxyrenounceMinterCall",
      id
    ) as AdminUpgradeabilityProxyrenounceMinterCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class AdminUpgradeabilityProxytransferCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save AdminUpgradeabilityProxytransferCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AdminUpgradeabilityProxytransferCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("AdminUpgradeabilityProxytransferCall", id.toString(), this);
  }

  static load(id: string): AdminUpgradeabilityProxytransferCall | null {
    return store.get(
      "AdminUpgradeabilityProxytransferCall",
      id
    ) as AdminUpgradeabilityProxytransferCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get recipient(): Bytes {
    let value = this.get("recipient");
    return value.toBytes();
  }

  set recipient(value: Bytes) {
    this.set("recipient", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get value0(): boolean {
    let value = this.get("value0");
    return value.toBoolean();
  }

  set value0(value: boolean) {
    this.set("value0", Value.fromBoolean(value));
  }
}

export class AdminUpgradeabilityProxytransferFromCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save AdminUpgradeabilityProxytransferFromCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AdminUpgradeabilityProxytransferFromCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("AdminUpgradeabilityProxytransferFromCall", id.toString(), this);
  }

  static load(id: string): AdminUpgradeabilityProxytransferFromCall | null {
    return store.get(
      "AdminUpgradeabilityProxytransferFromCall",
      id
    ) as AdminUpgradeabilityProxytransferFromCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get recipient(): Bytes {
    let value = this.get("recipient");
    return value.toBytes();
  }

  set recipient(value: Bytes) {
    this.set("recipient", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get value0(): boolean {
    let value = this.get("value0");
    return value.toBoolean();
  }

  set value0(value: boolean) {
    this.set("value0", Value.fromBoolean(value));
  }
}
